<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ç»ä¸ç©ºå†›ï¼šé’“é±¼ä½¬æ¨¡æ‹Ÿå™¨</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        :root {
            --primary-bg: #1a2f23; /* Deep Green */
            --secondary-bg: #243e30;
            --accent: #ff9800; /* Bright Orange */
            --text-main: #e0e0e0;
            --text-dim: #a0a0a0;
            --danger: #ff5252;
            --success: #69f0ae;
            --discount: #ff4081;
            --gold: #ffd700;
            --silver: #c0c0c0;
            --bronze: #cd7f32;
        }

        * { box-sizing: border-box; user-select: none; }
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            color: var(--text-main);
        }

        #app {
            width: 100%;
            max-width: 480px;
            height: 100%;
            background-color: var(--primary-bg);
            display: flex;
            flex-direction: column;
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        /* Animations */
        .fade-enter-active, .fade-leave-active { transition: opacity 0.3s; }
        .fade-enter-from, .fade-leave-to { opacity: 0; }
        
        .slide-up-enter-active { transition: all 0.4s ease-out; }
        .slide-up-enter-from { transform: translateY(20px); opacity: 0; }
        
        .toast-enter-active, .toast-leave-active { transition: all 0.5s ease; }
        .toast-enter-from, .toast-leave-to { transform: translateY(-50px); opacity: 0; }

        @keyframes blink-red {
            0% { color: var(--text-main); }
            50% { color: var(--danger); text-shadow: 0 0 5px var(--danger); }
            100% { color: var(--text-main); }
        }
        .blink-danger { animation: blink-red 1s infinite; font-weight: bold; }

        /* Typography */
        h1, h2, h3 { margin: 0; font-weight: 600; }
        .highlight { color: var(--accent); }
        .stat-val { font-family: monospace; font-weight: bold; }

        /* Layout Components */
        .header {
            padding: 15px;
            background: rgba(0,0,0,0.2);
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            border-bottom: 1px solid var(--secondary-bg);
        }
        .stat-col { display: flex; flex-direction: column; gap: 4px; }
        .stat-row { display: flex; justify-content: space-between; font-size: 0.9rem; align-items: center; }
        
        .main-area {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            text-align: center;
            /* Scroll Mask Effect */
            mask-image: linear-gradient(to bottom, black 90%, transparent 100%);
            -webkit-mask-image: linear-gradient(to bottom, black 90%, transparent 100%);
        }

        .log-area {
            height: 100px;
            background: rgba(0,0,0,0.3);
            margin: 10px;
            padding: 10px;
            overflow-y: auto;
            font-size: 0.8rem;
            text-align: left;
            border-radius: 4px;
        }
        .log-item { margin-bottom: 4px; color: var(--text-dim); }
        .log-item.new { color: var(--text-main); }

        .controls {
            padding: 20px;
            background: var(--secondary-bg);
            display: flex;
            flex-direction: column;
            gap: 10px;
            flex-shrink: 0;
        }

        .action-bar {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        /* Buttons */
        .btn {
            background: var(--accent);
            color: #000;
            border: none;
            padding: 12px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.1s, filter 0.1s;
            width: 100%;
        }
        .btn:active { transform: scale(0.98); }
        .btn:disabled { filter: grayscale(1); opacity: 0.5; cursor: not-allowed; }
        .btn-outline {
            background: transparent;
            border: 2px solid var(--accent);
            color: var(--accent);
        }
        .btn-small { padding: 8px 12px; font-size: 0.8rem; width: auto; flex: 1; }
        
        /* Categories */
        .category-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
            width: 100%;
            overflow-x: auto;
            padding-bottom: 5px;
        }
        .tab {
            padding: 6px 12px;
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
            font-size: 0.8rem;
            white-space: nowrap;
            cursor: pointer;
            border: 1px solid transparent;
        }
        .tab.active {
            background: var(--accent);
            color: #000;
            font-weight: bold;
        }

        /* Cards */
        .card {
            background: rgba(255,255,255,0.08); /* Slightly lighter */
            border-radius: 12px; /* Rounded corners */
            padding: 12px;
            /* margin-bottom: 8px; Removed for grid gap */
            width: 100%;
            text-align: left;
            cursor: pointer;
            border: 1px solid rgba(255,255,255,0.05); /* Thin subtle border */
            position: relative;
            display: grid;
            grid-template-columns: auto 1fr auto;
            gap: 10px;
            align-items: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2); /* Soft shadow */
            transition: transform 0.2s, box-shadow 0.2s, background 0.2s;
        }
        .card:active { transform: scale(0.98); }
        .card.selected { border-color: var(--accent); background: rgba(255,152,0,0.15); box-shadow: 0 0 15px rgba(255,152,0,0.2); }
        
        .shop-list {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
            width: 100%;
            padding-bottom: 120px; /* Increased padding */
        }
        @media (min-width: 450px) {
            .shop-list { grid-template-columns: 1fr 1fr; }
            .card { display: flex; flex-direction: column; text-align: center; height: 100%; align-items: center; }
            .card-price { margin-top: auto; width: 100%; text-align: center; font-size: 1rem; }
            .card-icon { font-size: 2.5rem; margin-bottom: 5px; }
            .card-info { width: 100%; }
        }

        .card-icon { font-size: 1.5rem; }
        .card-info { overflow: hidden; }
        .card-name { font-weight: bold; font-size: 0.9rem; }
        .card-desc { font-size: 0.7rem; color: var(--text-dim); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .card-price { font-size: 0.8rem; color: var(--accent); text-align: right; }
        
        .discount-badge {
            position: absolute;
            top: 5px;
            right: 5px;
            background: var(--discount);
            color: white;
            font-size: 0.6rem;
            padding: 2px 5px;
            border-radius: 4px;
            font-weight: bold;
            transform: rotate(10deg);
            z-index: 2; /* Ensure on top */
        }

        .event-img {
            font-size: 4rem;
            margin: 20px 0;
            display: block;
        }
        
        /* NPC Dialog */
        .npc-dialog {
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 15px;
            margin: 10px 0;
            text-align: left;
            border-left: 4px solid var(--accent);
            position: relative;
        }
        .npc-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        .npc-avatar {
            font-size: 2rem;
            background: #fff;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 2px solid var(--accent);
        }
        .npc-name {
            font-weight: bold;
            color: var(--accent);
        }
        .npc-text {
            font-size: 0.95rem;
            line-height: 1.5;
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            z-index: 100;
        }
        .modal {
            background: var(--secondary-bg);
            padding: 25px;
            border-radius: 12px;
            width: 100%;
            max-width: 400px;
            border: 1px solid var(--accent);
            text-align: center;
            max-height: 90vh;
            overflow-y: auto;
        }

        /* Achievement Toast */
        .toast-container {
            position: fixed;
            top: 20px;
            left: 0;
            right: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: none;
            z-index: 200;
        }
        .toast {
            background: rgba(0,0,0,0.9);
            border: 1px solid var(--gold);
            color: var(--gold);
            padding: 10px 20px;
            border-radius: 50px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3);
        }
        .toast.rare { border-color: var(--silver); color: var(--silver); box-shadow: 0 4px 15px rgba(192, 192, 192, 0.3); }
        .toast.normal { border-color: var(--bronze); color: var(--bronze); box-shadow: 0 4px 15px rgba(205, 127, 50, 0.3); }

        /* Trophy Room */
        .trophy-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 20px;
        }
        .trophy-item {
            aspect-ratio: 1;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            filter: grayscale(1) opacity(0.3);
            cursor: help;
            position: relative;
        }
        .trophy-item.unlocked {
            filter: none;
            background: rgba(255,255,255,0.05);
            border: 1px solid var(--accent);
        }
        .trophy-item.legend { border-color: var(--gold); box-shadow: 0 0 10px rgba(255,215,0,0.2); }
        
        /* License Poster */
        .license-card {
            background: #f4e4bc; /* Paper color */
            color: #333;
            padding: 20px;
            border-radius: 10px;
            position: relative;
            text-align: left;
            margin-top: 20px;
            border: 4px double #5a4632;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
        }
        .license-header {
            text-align: center;
            border-bottom: 2px solid #5a4632;
            padding-bottom: 10px;
            margin-bottom: 15px;
        }
        .license-title {
            font-size: 1.2rem;
            font-weight: bold;
            color: #5a4632;
            letter-spacing: 2px;
        }
        .license-body {
            display: grid;
            grid-template-columns: 80px 1fr;
            gap: 15px;
        }
        .license-photo {
            width: 80px;
            height: 100px;
            background: #ddd;
            border: 1px solid #999;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            flex-direction: column;
        }
        .license-info div { margin-bottom: 5px; font-size: 0.8rem; }
        .license-label { font-weight: bold; color: #5a4632; }
        .license-stamp {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 80px;
            height: 80px;
            border: 3px solid #d32f2f;
            border-radius: 50%;
            color: #d32f2f;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            transform: rotate(-20deg);
            font-size: 0.9rem;
            text-align: center;
            opacity: 0.8;
        }

        /* --- Scrollbar UI/UX Upgrade --- */
        
        /* 1. Custom Webkit Scrollbar */
        /* Apply globally to all scrollbars including body */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        ::-webkit-scrollbar-track {
            background: rgba(10, 30, 50, 0.4); /* Track: Deep Water Blue */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: rgba(255, 152, 0, 0.6); /* Thumb: Orange (Matches --accent) */
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 152, 0, 0.9); /* Brighter on hover */
        }
        ::-webkit-scrollbar-corner {
            background: transparent;
        }

        /* 2. Interaction & Mobile Optimization */
        body {
            overscroll-behavior: none; /* Prevent pull-to-refresh/rubber-banding */
            scrollbar-color: rgba(255, 152, 0, 0.6) rgba(10, 30, 50, 0.4); /* Firefox */
            scrollbar-width: thin;
        }

        /* Apply smooth scrolling and touch optimization to all scrollable areas */
        .main-area, .log-area, .modal, .category-tabs, .trophy-grid, .shop-list {
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch; /* iOS Momentum Scrolling */
            scrollbar-width: thin; /* Firefox Support */
            scrollbar-color: rgba(255, 152, 0, 0.6) rgba(10, 30, 50, 0.4); /* Firefox Support */
        }
        
    </style>
</head>
<body>

<div id="app">
    <!-- Achievement Toasts -->
    <div class="toast-container">
        <transition-group name="toast">
            <div v-for="toast in activeToasts" :key="toast.id" class="toast" :class="toast.rarity">
                <span style="font-size: 1.2rem;">ğŸ†</span>
                <div>
                    <div style="font-size: 0.8rem; font-weight: bold;">æˆå°±è§£é”</div>
                    <div>{{ toast.name }}</div>
                </div>
            </div>
        </transition-group>
    </div>

    <!-- Header Stats (Visible in Game) -->
    <header class="header" v-if="state.phase === 'JOURNEY'">
        <div class="stat-col">
            <div class="stat-row"><span>ä½“åŠ›</span> <span class="stat-val" :style="{color: state.stamina < 30 ? 'red' : ''}">{{ state.stamina }}</span></div>
            <div class="stat-row"><span>å¿ƒæ€</span> <span class="stat-val">{{ state.sanity }}</span></div>
            <div class="stat-row"><span>æ—¶é—´</span> <span class="stat-val">{{ state.stage }}/{{ MAX_STAGES }}</span></div>
        </div>
        <div class="stat-col">
            <div class="stat-row">
                <span>èµ„é‡‘</span>
                <span class="stat-val" style="color: var(--gold);">${{ state.money }}</span>
            </div>
            <div class="stat-row">
                <span>é¥µæ–™</span> 
                <span class="stat-val" :class="{'blink-danger': isLowBait}">
                    {{ state.bait }}
                    <span style="font-size: 0.8rem;">ğŸ¥«</span>
                </span>
            </div>
            <div class="stat-row">
                <span>æ¸”è·</span> 
                <span class="stat-val highlight">{{ state.catchWeight.toFixed(1) }}kg</span>
            </div>
            <div class="stat-row" v-if="state.maxFishWeight > 0">
                <span style="font-size: 0.8rem; color: #ffd700;">æœ€å¤§</span>
                <span class="stat-val" :style="{
                    color: state.maxFishWeight > 5.0 ? '#ff4081' : '#ffd700',
                    textShadow: state.maxFishWeight > 5.0 ? '0 0 5px #ff4081' : 'none',
                    fontWeight: 'bold'
                }">
                    {{ state.maxFishWeight.toFixed(1) }}kg
                </span>
            </div>
        </div>
    </header>

    <!-- MAIN CONTENT AREA -->
    <main class="main-area" :style="{justifyContent: state.phase === 'PREPARE' ? 'flex-start' : 'center'}">
        
        <!-- START SCREEN -->
        <div v-if="state.phase === 'START'" class="slide-up">
            <div style="font-size: 5rem; margin-bottom: 20px;">ğŸ£</div>
            <h1 style="font-size: 2rem; margin-bottom: 10px;">ç»ä¸ç©ºå†›</h1>
            <p style="color: var(--text-dim);">é’“é±¼ä½¬æ¨¡æ‹Ÿå™¨</p>
            <div style="margin-top: 50px;">
                <p>ç»ˆæç›®æ ‡ï¼šé’“åˆ°å¤§é±¼</p>
                <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
                    <button class="btn" @click="startGame">å¼€å§‹é’“é±¼</button>
                </div>
                <button class="btn btn-outline" style="margin-top: 10px;" @click="showTrophyRoom = true">è£èª‰å®¤ ğŸ†</button>
            </div>
        </div>

        <!-- PREPARE SCREEN -->
        <div v-if="state.phase === 'PREPARE'" class="slide-up" style="width: 100%;">
            <div style="position: sticky; top: 0; background: var(--primary-bg); z-index: 10; padding-bottom: 10px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <h2 style="font-size: 1.2rem;">æ¸”å…·åº—</h2>
                    <div style="text-align: right;">
                        <div>èµ„é‡‘: <span class="highlight">${{ state.money }}</span></div>
                        <div style="font-size: 0.8rem;">èƒŒåŒ…: {{ state.inventory.length }}/7</div>
                    </div>
                </div>

                <div class="category-tabs">
                    <div 
                        v-for="(label, key) in CATEGORIES" 
                        :key="key" 
                        class="tab" 
                        :class="{active: activeTab === key}"
                        @click="activeTab = key"
                    >
                        {{ label }}
                    </div>
                </div>

                <!-- Stats Panel -->
                <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px; margin-bottom: 10px; font-size: 0.8rem;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 5px; color: var(--text-dim);">
                        <span>å½“å‰é…ç½®çŠ¶æ€</span>
                        <span v-if="compatibilityWarning" class="blink-danger">!</span>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 5px; text-align: center;">
                        <div style="background: rgba(255,255,255,0.05); padding: 5px; border-radius: 4px;">
                            <div style="color: #aaa;">è´Ÿé‡</div>
                            <div :style="{color: currentWeight > 10 ? 'red' : currentWeight > 8 ? 'orange' : 'var(--success)'}">
                                {{ currentWeight.toFixed(1) }}/10kg
                            </div>
                        </div>
                        <div style="background: rgba(255,255,255,0.05); padding: 5px; border-radius: 4px;">
                            <div style="color: #aaa;">æ‹‰åŠ›</div>
                            <div style="color: var(--accent);">{{ currentStats.maxDrag > 99 ? 'âˆ' : currentStats.maxDrag.toFixed(1) }}kg</div>
                        </div>
                        <div style="background: rgba(255,255,255,0.05); padding: 5px; border-radius: 4px;">
                            <div style="color: #aaa;">çµæ•åº¦</div>
                            <div :style="{color: currentStats.sensitivity >= 20 ? 'var(--success)' : currentStats.sensitivity < 0 ? 'red' : 'white'}">
                                {{ currentStats.sensitivity > 0 ? '+' : ''}}{{ currentStats.sensitivity }}
                            </div>
                        </div>
                    </div>
                    
                    <div v-if="compatibilityWarning" style="margin-top: 5px; color: var(--danger); font-size: 0.75rem; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 5px;">
                        {{ compatibilityWarning }}
                    </div>
                </div>
            </div>
            
            <div class="shop-list">
                <div 
                    v-for="item in filteredItems" 
                    :key="item.id" 
                    class="card"
                    :class="{ selected: state.inventory.includes(item.id) }"
                    @click="toggleItem(item)"
                >
                    <div class="card-icon">{{ item.icon }}</div>
                    <div class="card-info">
                        <div class="card-name">{{ item.name }}</div>
                        <div class="card-desc">{{ item.desc }}</div>
                        <div v-if="item.baitVal" style="font-size: 0.7rem; color: var(--success);">é¥µæ–™å€¼ +{{ item.baitVal }}</div>
                    </div>
                    <div class="card-price">
                        <div v-if="isDiscounted(item.id)" style="color: var(--discount);">
                            ${{ item.price / 2 }}
                        </div>
                        <div v-else>${{ item.price }}</div>
                    </div>
                    <div v-if="isDiscounted(item.id)" class="discount-badge">-50%</div>
                </div>
            </div>

            <div style="position: fixed; bottom: 20px; left: 0; right: 0; padding: 20px; background: linear-gradient(transparent, var(--primary-bg) 20%); pointer-events: none; display: flex; justify-content: center;">
                 <button class="btn" style="pointer-events: auto; max-width: 440px; box-shadow: 0 4px 12px rgba(0,0,0,0.5);" @click="startJourney">
                    å‡ºå‘ ({{ state.inventory.length }}/7)
                </button>
            </div>
        </div>

        <!-- JOURNEY SCREEN -->
        <div v-if="state.phase === 'JOURNEY'" class="slide-up" key="journey">
            <div class="event-img" v-if="!currentEvent?.npc">{{ currentEvent?.icon || 'â“' }}</div>
            
            <!-- NPC Dialog -->
            <div v-if="currentEvent?.npc" class="npc-dialog">
                <div v-if="currentEvent.atmosphere_intro" style="font-style: italic; color: var(--text-dim); margin-bottom: 10px; font-size: 0.85rem;">
                    {{ currentEvent.atmosphere_intro }}
                </div>
                <div class="npc-header">
                    <div class="npc-avatar">{{ currentEvent.npc.avatar }}</div>
                    <div class="npc-name">{{ currentEvent.npc.name }}</div>
                </div>
                <div class="npc-text">{{ currentEvent.text }}</div>
            </div>
            <div v-else>
                <h2 style="margin-bottom: 15px;">{{ currentEvent?.title }}</h2>
                <p style="line-height: 1.6;">{{ currentEvent?.text }}</p>
            </div>
            
            <!-- Effect Feedback -->
            <div v-if="feedback" style="margin-top: 20px; color: var(--success); font-weight: bold;">
                {{ feedback }}
            </div>
        </div>

        <!-- MARKET INTRO SCREEN -->
        <div v-if="state.phase === 'MARKET_INTRO'" class="slide-up" style="text-align: left; padding: 20px;">
             <h2 style="margin-bottom: 20px; color: var(--accent);">æ”¶ç«¿æ—¶åˆ»...</h2>
             <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; margin-bottom: 20px; line-height: 1.6;">
                 <p>å¤•é˜³è¥¿ä¸‹ï¼Œä½ æç€ç©ºç©ºå¦‚ä¹Ÿçš„é±¼æŠ¤ï¼Œç«™åœ¨è·¯è¾¹ã€‚</p>
                 <p>è¿™æ˜¯ç¬¬ <span class="highlight">{{ state.fishedCount }}</span> æ¬¡æŠ›ç«¿ï¼Œç»“æœä¾ç„¶æ˜¯ <span class="highlight" style="color: var(--danger);">0</span> æ¸”è·ã€‚</p>
                 <p>æƒ³èµ·å‡ºé—¨å‰è€å©†æœŸå¾…çš„çœ¼ç¥ï¼Œæƒ³èµ·é‚»å±…è€ç‹å˜²è®½çš„å˜´è§’...</p>
                 <p style="margin-top: 15px; font-style: italic; color: var(--text-dim);">"éš¾é“å°±è¿™æ ·å›å»å—ï¼Ÿ"</p>
                 <p>è¿œå¤„ï¼Œ<span class="highlight">èœå¸‚åœº</span> çš„ç¯å…‰ä¾ç„¶äº®ç€ï¼Œä»¿ä½›æ˜¯æœ€åçš„æ•‘èµã€‚</p>
             </div>
             <button class="btn" @click="enterMarket">å‰å¾€èœå¸‚åœº (ç»åœ°åå‡»)</button>
             <button class="btn btn-outline" style="margin-top: 10px;" @click="leaveMarket">å¦ç„¶æ¥å— (ç›´æ¥å›å®¶)</button>
        </div>

        <!-- MARKET SCREEN -->
        <div v-if="state.phase === 'MARKET'" class="slide-up">
            <h2 style="margin-bottom: 10px;">è·¯è¿‡èœå¸‚åœº</h2>
            <p style="margin-bottom: 20px; color: var(--text-dim);">çœ‹ç€ç©ºç©ºçš„é±¼æŠ¤ï¼Œä½ åŠ¨äº†æ­ªå¿ƒæ€...<br>å½“å‰èµ„é‡‘: <span class="highlight">${{ state.money }}</span></p>
            
            <div style="display: flex; flex-direction: column; gap: 10px; width: 100%;">
                <div v-for="item in MARKET_ITEMS" :key="item.id" class="card" @click="buyFish(item)">
                    <div class="card-icon">{{ item.icon }}</div>
                    <div class="card-info">
                        <div class="card-name">{{ item.name }}</div>
                        <div class="card-desc" style="color: var(--danger);">
                            è¯†ç ´ç‡: {{ (getRealProb(item) * 100).toFixed(0) }}%
                            <span v-if="state.inventory.includes('huazi')" style="color: var(--success); font-size: 0.8em;">(åå­ä¿ä½‘)</span>
                        </div>
                    </div>
                    <div class="card-price" :style="{color: state.money < item.price ? 'gray' : 'var(--accent)'}">
                        ${{ item.price }}
                    </div>
                </div>
            </div>

            <button class="btn btn-outline" style="margin-top: 20px;" @click="leaveMarket">
                ç®—äº†ï¼Œå›å®¶ (ç»“æŸ)
            </button>
        </div>

    </main>

    <!-- CONTROLS (JOURNEY ONLY) -->
    <div class="controls" v-if="state.phase === 'JOURNEY'">
        <!-- Action Bar for Meme/Strategic Actions -->
        <div class="action-bar" v-if="currentEvent?.id !== 'no_bait'">
            <button class="btn btn-outline btn-small" @click="doHeavyChum" :disabled="state.bait < 10 || state.heavyChum">
                é‡çª (-10) {{ state.heavyChum ? 'âœ…' : '' }}
            </button>
            <button class="btn btn-outline btn-small" @click="doTasteBait" :disabled="state.bait <= 0 || state.sanity > 50">
                èˆ”ä¸€å£é¥µ
            </button>
        </div>

        <button 
            v-for="(choice, idx) in currentEvent?.choices" 
            :key="idx" 
            class="btn btn-outline"
            @click="handleChoice(choice)"
            :disabled="!canAfford(choice)"
        >
            {{ choice.text }} 
            <span v-if="choice.cost" style="font-size: 0.8rem; opacity: 0.7;">
                (-{{ choice.cost.val }} {{ choice.cost.type === 'stamina' ? 'ä½“åŠ›' : choice.cost.type === 'sanity' ? 'å¿ƒæ€' : choice.cost.type === 'money' ? 'èµ„é‡‘' : choice.cost.type === 'bait' ? 'é¥µæ–™' : '?' }})
            </span>
        </button>
        <div class="log-area" ref="logContainer">
            <div v-for="(log, i) in state.logs" :key="i" class="log-item" :class="{new: i === state.logs.length-1}">
                > {{ log }}
            </div>
        </div>
    </div>

    <!-- ENDING MODAL -->
    <div v-if="state.phase === 'ENDED'" class="modal-overlay">
        <div class="modal slide-up">
            <h2>{{ endingTitle }}</h2>
            <div style="font-size: 3rem; margin: 20px 0;">{{ endingIcon }}</div>
            
            <div style="text-align: left; margin-bottom: 20px; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px;">
                <div>æœ€ç»ˆæ¸”è·: <span class="highlight">{{ state.catchWeight.toFixed(1) }}kg</span></div>
                <div>å‰©ä½™é¥µæ–™: {{ state.bait }}</div>
                <div>å‰©ä½™ä½“åŠ›: {{ state.stamina }}</div>
            </div>

            <!-- Narrative Result (Busted or Success) -->
            <div v-if="state.flags.marketBusted" style="margin-bottom: 20px; color: var(--danger); font-style: italic;">
                "{{ marketText }}"
            </div>
            <div v-else-if="state.flags.marketSuccess" style="margin-bottom: 20px; color: var(--success); font-style: italic;">
                "ä½ æç€æ²‰ç”¸ç”¸çš„é±¼è¿›å®¶é—¨ï¼Œå®¶äººçš„çœ¼ç¥å……æ»¡å´‡æ‹œã€‚"
            </div>

            <!-- Funny Moment -->
            <div v-if="randomFunnyMoment" style="margin-bottom: 20px; border-left: 4px solid var(--accent); background: rgba(0,0,0,0.2); padding: 10px; text-align: left;">
                <div style="font-weight: bold; color: var(--accent); font-size: 0.9rem;">ä»Šæ—¥ç³—äº‹</div>
                <div style="font-size: 0.8rem; color: var(--text-dim);">{{ randomFunnyMoment }}</div>
            </div>

            <div v-if="newAchievements.length > 0" style="margin-bottom: 20px;">
                <h3 style="color: var(--accent); font-size: 0.9rem;">æœ¬å±€è§£é”æˆå°±</h3>
                <div style="display: flex; flex-wrap: wrap; justify-content: center;">
                    <div v-for="ach in newAchievements" :key="ach" style="font-size: 0.8rem; border: 1px solid var(--accent); border-radius: 4px; display: inline-block; padding: 2px 6px; margin: 2px;">
                        {{ ach }}
                    </div>
                </div>
            </div>

            <p style="font-size: 0.8rem; color: var(--text-dim); font-style: italic;">
                "{{ shareText }}"
            </p>

            <!-- LICENSE CARD (Hidden initially, shown for screenshot) -->
            <div id="license-node" class="license-card">
                <div class="license-header">
                    <div class="license-title">é’“é±¼èµ„æ ¼è¯</div>
                    <div style="font-size: 0.6rem; color: #5a4632;">NEVER AIR FORCE ASSOCIATION</div>
                </div>
                <div class="license-body">
                    <div class="license-photo">
                        <div>ğŸ£</div>
                        <div style="font-size: 0.5rem; margin-top:5px;">{{ state.bait > 0 ? 'æœ‰ç²®' : 'æ–­ç²®' }}</div>
                    </div>
                    <div class="license-info">
                        <div><span class="license-label">å§“å:</span> ç»ä¸ç©ºå†›çš„é’“é±¼ä½¬</div>
                        <div><span class="license-label">æ—¥æœŸ:</span> {{ currentDate }}</div>
                        <div><span class="license-label">æœ€é«˜è£èª‰:</span> <span style="color: #d32f2f; font-weight: bold;">{{ highestHonor }}</span></div>
                        <div><span class="license-label">æœ¬æ¬¡æ¸”è·:</span> {{ state.catchWeight.toFixed(1) }}kg</div>
                        <div><span class="license-label">çŠ¶æ€:</span> {{ state.stamina > 0 ? 'è‰¯å¥½' : 'æ™•å¥' }}</div>
                    </div>
                </div>
                <div class="license-stamp" :style="{borderColor: stampColor, color: stampColor}">
                    {{ stampText }}
                </div>
            </div>

            <div style="display: flex; gap: 10px; justify-content: center; margin-top: 15px;">
                <button class="btn" @click="resetGame">å†æ¥ä¸€ç«¿</button>
                <button class="btn btn-outline" @click="generatePoster">ğŸ“¸ ç”Ÿæˆæ‰§ç…§</button>
            </div>
        </div>
    </div>

    <!-- TROPHY ROOM MODAL -->
    <div v-if="showTrophyRoom" class="modal-overlay" @click.self="showTrophyRoom = false">
        <div class="modal slide-up" style="max-width: 450px;">
            <h2>è£èª‰å®¤</h2>
            <p style="font-size: 0.8rem; color: var(--text-dim);">å·²è§£é”: {{ unlockedCount }}/{{ ACHIEVEMENTS.length }}</p>
            
            <div class="trophy-grid">
                <div 
                    v-for="ach in ACHIEVEMENTS" 
                    :key="ach.id" 
                    class="trophy-item"
                    :class="{ unlocked: hasAchievement(ach.id), legend: ach.rarity === 'legend' }"
                    @click="showAchDetail(ach)"
                >
                    <span v-if="hasAchievement(ach.id)">{{ ach.icon || 'ğŸ†' }}</span>
                    <span v-else>?</span>
                </div>
            </div>

            <div v-if="selectedAch" style="margin-top: 20px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 8px;">
                <div style="font-weight: bold; color: var(--accent);">{{ selectedAch.name }}</div>
                <div style="font-size: 0.8rem; margin: 5px 0;">{{ selectedAch.desc }}</div>
                <div style="font-size: 0.7rem; color: var(--text-dim);">{{ selectedAch.rarity.toUpperCase() }}</div>
            </div>

            <button class="btn" style="margin-top: 20px;" @click="showTrophyRoom = false">è¿”å›</button>
        </div>
    </div>

</div>

<script>
const { createApp, reactive, computed, ref, nextTick, onMounted, watch } = Vue;

const CATEGORIES = { 
    ROD: 'æ ¸å¿ƒé±¼ç«¿', 
    LINE: 'çº¿ç»„', 
    FLOAT: 'æµ®æ¼‚',
    BAIT: 'é¥µæ–™å°è¯', 
    AUX: 'è¾…åŠ©è£…å¤‡', 
    SURVIVAL: 'æˆ·å¤–ç”Ÿå­˜', 
    MEME: 'ç„å­¦çƒ­æ¢—' 
};

const ITEMS_DB = [
    // 1. é±¼ç«¿ (Rods)
    { id: 'rod_general_45', name: '4.5ç±³ç»¼åˆç«¿', price: 300, weight: 1.0, category: 'ROD', desc: 'æ‰‹æ„Ÿé€‚ä¸­ï¼Œé€‚åˆä¼‘é—²é‡é’“ã€‚', icon: 'ğŸ‹', strength: 5.0 },
    { id: 'rod_carbon_light', name: 'è¶…è½»ç¢³ç´ çŸ­èŠ‚ç«¿', price: 700, weight: 0.5, category: 'ROD', desc: 'è½»è‹¥æ— ç‰©ï¼Œä¹…æŒä¸ç´¯ï¼Œä½†çœ‹èµ·æ¥å¾ˆè„†ã€‚', icon: 'ğŸ¥¢', strength: 2.0 },
    { id: 'rod_giant_72', name: '7.2ç±³å·¨ç‰©é»‘æ£', price: 1200, weight: 3.0, category: 'ROD', desc: 'é‡å¾—åƒæ ¹çƒ§ç«æ£ï¼Œä¸“é—¨å¯¹ä»˜æ°´åº“å·¨å…½ã€‚', icon: 'ğŸ¥–', strength: 100.0 },
    { id: 'rod_lure', name: 'è·¯äºšä¼¸ç¼©ç«¿', price: 500, weight: 0.8, category: 'ROD', desc: 'é€ å‹å¸…æ°”ï¼Œé€‚åˆå–œæ¬¢ä¸»åŠ¨å‡ºå‡»çš„å¹´è½»äººã€‚', icon: 'ğŸ£', strength: 4.0 },

    // 2. çº¿ç»„ (Lines) - New Logic
    { id: 'line_08_thin', name: '0.8å·è¢–é’©ç»†çº¿', price: 60, weight: 0.1, category: 'LINE', desc: 'ç»†å¦‚å‘ä¸ï¼Œéšè”½æ€§æä½³ï¼Œä½†ç»ä¸èµ·æŠ˜è…¾ã€‚', icon: 'ğŸ§µ', maxLoad: 2.0, sensitivity: 20 },
    { id: 'line_30_gen', name: '3.0å·ç»¼åˆçº¿', price: 100, weight: 0.1, category: 'LINE', desc: 'ä¸‡é‡‘æ²¹çº¿ç»„ï¼Œå¦‚æœä¸è¿½æ±‚æè‡´çš„è¯ã€‚', icon: 'ğŸ§¶', maxLoad: 5.0, sensitivity: 10 },
    { id: 'line_80_pe', name: '8.0å·å¤§åŠ›é©¬çº¿', price: 250, weight: 0.2, category: 'LINE', desc: 'èƒ½æ‹‰åŠ¨æ±½è½¦çš„ç»³å­ï¼Œé±¼çœ‹åˆ°å¯èƒ½ä¼šè¢«å“è·‘ã€‚', icon: 'â›“ï¸', maxLoad: 100.0, sensitivity: -10 },

    // 3. æµ®æ¼‚ (Floats) - New Logic
    { id: 'float_reed', name: 'èŠ¦è‹‡çµæ•æ¼‚', price: 100, weight: 0.1, category: 'FLOAT', desc: 'æå…¶çµæ•çš„çº¯æ‰‹å·¥æ¼‚ï¼Œé£ä¸€å¹å°±ä¹±æ™ƒã€‚', icon: 'ğŸ¥¢', sensitivity: 20 },
    { id: 'float_electric', name: 'åŠ ç²—ç”µå­æ¼‚', price: 250, weight: 0.2, category: 'FLOAT', desc: 'å‘å‡ºè€€çœ¼çš„è“å…‰ï¼Œä½†ä¼¼ä¹æœ‰ç‚¹ç¬¨é‡ã€‚', icon: 'ğŸ’¡', sensitivity: 0 },

    // 4. é¥µæ–™ (Baits)
    { id: 'bait_red_worms', name: 'æ´»ä½“çº¢è™«', price: 80, weight: 0.5, category: 'BAIT', desc: 'é²œæ´»è •åŠ¨ï¼Œå¯¹æ‰€æœ‰é±¼ç±»éƒ½æœ‰è‡´å‘½è¯±æƒ‘åŠ›ã€‚', icon: 'ğŸ›', baitVal: 40 },
    { id: 'bait_grain', name: 'äº”è°·æ‚ç²®çªæ–™', price: 200, weight: 1.0, category: 'BAIT', desc: 'æœ´å®æ— åçš„ç²®é£Ÿï¼Œéœ€è¦æ—¶é—´å‘é…µã€‚', icon: 'ğŸŒ½', baitVal: 80 }, // Weight reduced to 1kg per user example
    { id: 'bait_potion', name: 'ç¥ç§˜å°è¯', price: 350, weight: 0.2, category: 'BAIT', desc: 'æ•£å‘ç€ä¸å¯æè¿°çš„åŒ–å­¦æ°”å‘³ï¼Œæ•ˆæœæœªçŸ¥ã€‚', icon: 'ğŸ§ª', baitVal: 50 },

    // 5. è¾…åŠ© (Aux)
    { id: 'aux_box', name: 'å¤šåŠŸèƒ½é’“ç®±', price: 500, weight: 5.0, category: 'AUX', desc: 'ä¸ä»…èƒ½è£…ï¼Œåç€è¿˜èˆ’æœï¼Œå°±æ˜¯æœ‰ç‚¹æ²‰ã€‚', icon: 'ğŸ“¦' },
    { id: 'aux_chair', name: 'æŠ˜å é’“æ¤…', price: 250, weight: 2.0, category: 'AUX', desc: 'è½»ä¾¿æ˜“æºå¸¦ï¼Œä¹…åå¯èƒ½ä¼šè…°ç–¼ã€‚', icon: 'ğŸª‘' },
    { id: 'aux_ice_bucket', name: 'è‡ªåˆ¶é™æ¸©å†°æ¡¶', price: 400, weight: 4.0, category: 'AUX', desc: 'å¤æ—¥å¿…å¤‡ï¼Œæˆ–è®¸è¿˜æœ‰åˆ«çš„ç”¨é€”ï¼Ÿ', icon: 'ğŸ§Š' },
    
    // 6. ç”Ÿå­˜ (Survival)
    { id: 'powerbank', name: 'å¤§å®¹é‡å……ç”µå®', price: 200, weight: 0.5, category: 'SURVIVAL', desc: 'ç°ä»£äººçš„ç”Ÿå‘½ç»´æŒè£…ç½®ã€‚', icon: 'ğŸ”‹' },
    { id: 'big_umbrella', name: 'åŠ å¤§é˜²é›·ä¼', price: 400, weight: 1.5, category: 'SURVIVAL', desc: 'å·¨å¤§çš„ä¼é¢ï¼Œèƒ½é®é£æŒ¡é›¨ï¼Œç”šè‡³å¼•é›·ã€‚', icon: 'â˜‚ï¸' },
    { id: 'huazi', name: 'åå­(ä¸€ç›’)', price: 100, weight: 0.1, category: 'SURVIVAL', desc: 'æ•£å‘ç€å°Šè´µçš„æ°”æ¯ï¼Œäººæƒ…ä¸–æ•…çš„æ•²é—¨ç –ã€‚', icon: 'ğŸš¬' },
    { id: 'noodles', name: 'æ¡¶è£…æ–¹ä¾¿é¢', price: 50, weight: 0.3, category: 'SURVIVAL', desc: 'æ·±å¤œæŠšæ…°çµé­‚çš„ç¢³æ°´ç‚¸å¼¹ã€‚', icon: 'ğŸœ' },
    { id: 'spray', name: 'é©±èšŠå–·é›¾', price: 80, weight: 0.2, category: 'SURVIVAL', desc: 'å«æœ‰é¿èšŠèƒºï¼Œæˆ·å¤–ç”Ÿå­˜å¿…å¤‡ã€‚', icon: 'ğŸ¦Ÿ' },
    { id: 'sausage', name: 'è¿‡æœŸç«è…¿è‚ ', price: 30, weight: 0.1, category: 'SURVIVAL', desc: 'åŒ…è£…è¢‹æœ‰ç‚¹è¤ªè‰²ï¼Œé—»èµ·æ¥å‘³é“æ€ªæ€ªçš„ã€‚', icon: 'ğŸŒ­' },
    
    // 7. Meme
    { id: 'broken_net', name: 'ç ´æ´æŠ„ç½‘', price: 50, weight: 0.5, category: 'MEME', desc: 'ä¸çŸ¥æ˜¯è°æ‰”æ‰çš„ï¼Œç½‘å…œä¸Šæœ‰ä¸ªå¤§æ´ã€‚', icon: 'ğŸ•¸ï¸' },
    { id: 'gold_disgorger', name: 'é‡‘è‰²æŒ¡é’ˆ', price: 666, weight: 0.1, category: 'MEME', desc: 'çº¯é‡‘æ‰“é€ ï¼Œæ•£å‘ç€åœŸè±ªçš„å…‰èŠ’ã€‚', icon: 'ğŸ”±' },
    { id: 'skin', name: 'æœ€é“çš„ä»”', price: 999, weight: 0.0, category: 'MEME', desc: 'å…¨å¥—è§å…‰ç»¿é’“é±¼æœï¼Œå¤œç©ºä¸­æœ€äº®çš„æ˜Ÿã€‚', icon: 'ğŸ•º' },
];

const MARKET_ITEMS = [
    { id: 'market_grass', name: 'åŠæ­»ä¸æ´»çš„è‰é±¼', price: 100, weight: 3, prob: 0.2, icon: 'ğŸŸ' },
    { id: 'market_black', name: 'ç”ŸçŒ›æ°´åº“å¤§é’é±¼', price: 500, weight: 15, prob: 0.6, icon: 'ğŸ¦ˆ' },
    { id: 'market_turbot', name: 'æ˜‚è´µçš„æ·±æµ·å¤šå®é±¼', price: 1000, weight: 2, prob: 0.95, icon: 'ğŸ ' }
];

const ACHIEVEMENTS = [
    { id: 'air_force_commander', name: 'ç©ºå†›åŸºåœ°æ€»å¸ä»¤', desc: 'æ¸¸æˆç»“æŸæ—¶æ¸”è·ä¸º0', rarity: 'legend', icon: 'ğŸª£' },
    { id: 'newbie_luck', name: 'æ–°æ‰‹ä¿æŠ¤æœŸ', desc: 'ç¬¬ä¸€å›åˆé’“åˆ°5kgä»¥ä¸Šçš„å¤§é±¼', rarity: 'normal', icon: 'ğŸ¼' },
    { id: 'pure_fish', name: 'é™†å†›ç¥æªæ‰‹', desc: 'æ¸”è·å…¨æ˜¯â€œçœŸé±¼â€ï¼ˆæ— åƒåœ¾ï¼‰', rarity: 'rare', icon: 'ğŸŸ' },
    { id: 'never_empty', name: 'æ°¸ä¸èµ°ç©º', desc: 'æ²¡é’“åˆ°é±¼ä½†å¸¦èµ°äº†é¸¡/é¸­/æ°´', rarity: 'normal', icon: 'ğŸ”' },
    { id: 'line_breaker', name: 'åˆ‡çº¿ç‹‚é­”', desc: 'ç´¯è®¡åˆ‡çº¿5æ¬¡', rarity: 'normal', icon: 'âœ‚ï¸' },
    { id: 'lightning_rod', name: 'å…¨æ‘åƒé¥­', desc: 'é›·é›¨å¤©æ— ä¼è¢«åŠˆ', rarity: 'legend', icon: 'âš¡' },
    { id: 'bait_master', name: 'æ‰“çªä»™äºº', desc: 'æºå¸¦4ç§é¥µæ–™ä½†æ¸”è·<1kg', rarity: 'rare', icon: 'ğŸš' },
    { id: 'social_king', name: 'ç¤¾äº¤ææ€–åˆ†å­', desc: 'ç”¨åå­è§£å†³3æ¬¡å†²çª', rarity: 'normal', icon: 'ğŸ¤' },
    { id: 'super_catch', name: 'çˆ†æŠ¤ï¼', desc: 'å•å±€æ¸”è·è¶…è¿‡50kg', rarity: 'legend', icon: 'âš–ï¸' },
    { id: 'ultimate_regret', name: 'ç»ˆæé—æ†¾', desc: 'æ‹‰ç«¿ç¬é—´æ‰‹æœºæ²¡ç”µæˆ–å¿ƒæ€å´©äº†', rarity: 'rare', icon: 'ğŸ’”' },
    { id: 'duck_flew', name: 'åˆ°æ‰‹çš„é¸­å­é£äº†', desc: 'å› æŠ„ç½‘ç ´æ´è·‘é±¼', rarity: 'normal', icon: 'ğŸ¦†' },
    { id: 'empty_promises', name: 'ç©ºå¤´æ”¯ç¥¨', desc: 'å¸¦äº†ä¸€å †é¥µæ–™ï¼Œä¸€æ¬¡ç«¿éƒ½æ²¡æŠ›(å…¨æ‰“çªäº†)', rarity: 'rare', icon: 'ğŸ’¸' },
    { id: 'survivalist', name: 'ç»åœ°æ±‚ç”Ÿ', desc: 'é¥µæ–™è€—å°½åç”¨è·¯è¾¹çš„èš¯èš“é’“åˆ°é±¼', rarity: 'legend', icon: 'ğŸ§Ÿ' },
    { id: 'water_feeder', name: 'æ°´åº“å–‚é±¼å‘˜', desc: 'å’Œé’“å‹æ¯”æ‹¼æ‰“çªï¼Œç»“æœä¾ç„¶ç©ºå†›', rarity: 'normal', icon: 'ğŸ¥£' },
    { id: 'cheater', name: 'ä½œå¼Šç©å®¶', desc: 'è´­ä¹°è€ä¹¡çš„é±¼è¯•å›¾è’™æ··è¿‡å…³', rarity: 'rare', icon: 'ğŸ¤¥' },
    { id: 'broken_heart', name: 'é“å¿ƒç ´ç¢', desc: 'è¢«æ ‘æå¤§çˆ·å˜²è®½åˆ°é€€å‘', rarity: 'legend', icon: 'ğŸ’”' },
    { id: 'bad_acting', name: 'ç”±äºæ¼”æŠ€è¿‡äºæ‹™åŠ£...', desc: 'åœ¨èœå¸‚åœºä¹°é±¼è¢«å®¶äººå½“åœºæ‹†ç©¿', rarity: 'normal', icon: 'ğŸ­' },
    { id: 'movie_star', name: 'å½±å¸çº§é’“æ‰‹', desc: 'æˆåŠŸç”¨ä¹°æ¥çš„é±¼éª—è¿‡äº†æ‰€æœ‰äºº', rarity: 'legend', icon: 'ğŸ¬' }
];

const EVENTS = [
    { id: 'no_bait', title: 'å¼¹å°½ç²®ç»', text: 'é¥µæ–™ç›’æ¯”ä½ çš„è„¸è¿˜å¹²å‡€ã€‚', icon: 'ğŸš«', choices: [
        { text: 'å¯»æ‰¾æ›¿ä»£å“ (æ¶ˆè€—ä½“åŠ›)', type: 'find_worms', cost: { type: 'stamina', val: 20 } }, 
        { text: 'å›å®¶åƒé¥­', type: 'give_up' }
    ]},
    // NPC EVENTS (Updated with JSON Spec)
    { 
        id: 'grandpa_mockery', 
        title: 'æ ‘ææˆ˜ç¥çš„å˜²è®½', 
        atmosphere_intro: 'å¾®é£æ‹‚è¿‡ï¼Œæ­¤æ—¶çš„æ°´é¢é™å¾—å¯æ€•ï¼Œä½ æ‰‹é‡Œé‚£æ ¹æ˜‚è´µçš„ç¢³ç´ é±¼ç«¿æ˜¾å¾—æœ‰äº›çƒ«æ‰‹ã€‚çªç„¶ï¼Œèº«åä¼ æ¥ä¸€é˜µè¸¢è¸è¸¢è¸çš„æ‹–é‹å£°ï¼Œæ‰“ç ´äº†è¿™ä»½å°´å°¬çš„å®é™â€¦â€¦',
        text: 'æ—è¾¹è·‘æ¥ä¸€ä¸ªç©¿èƒŒå¿ƒçš„å¤§çˆ·ï¼Œéšæ‰‹æŠ˜äº†ä¸€æ ¹æŸ³æ ‘æï¼Œç³»ä¸Šç¼è¡£çº¿å’Œæ›²åˆ«é’ˆï¼ŒæŒ‚äº†åŠæ¡è¾£æ¡ã€‚', 
        npc: { name: 'å¤§çˆ·', avatar: 'ğŸ‘´' },
        cond: (s) => (s.inventory.includes('rod_carbon_light') || s.inventory.includes('rod_lure')) && s.catchWeight === 0 && Math.random() < 0.6,
        choices: [
            { text: 'ä¸å±‘ä¸€é¡¾', type: 'grandpa_ignore', cost: { type: 'sanity', val: 10 } },
            { text: 'è™šå¿ƒæ±‚æ•™ (éœ€åå­)', type: 'grandpa_learn', req: 'huazi' },
            { text: 'æ€€ç–‘äººç”Ÿ (ç»“æŸæ¸¸æˆ)', type: 'grandpa_quit' }
        ]
    },
    {
        id: 'air_force_alliance',
        title: 'ç©ºå†›é˜µçº¿è”ç›Ÿ',
        atmosphere_intro: 'å¤•é˜³å°†æ°´é¢æ¸¡äº†ä¸€å±‚é‡‘ï¼Œå››å‘¨å®‰é™å¾—åªèƒ½å¬è§èšŠå­çš„å—¡å—¡å£°ã€‚ä½ ç™¾æ— èŠèµ–åœ°æŠ¬èµ·å¤´ï¼Œç›®å…‰è¶Šè¿‡æ°´é¢â€¦â€¦',
        text: 'ä½ å’Œå¯¹å²¸çš„é’“å‹å¯¹è§†äº†ä¸€çœ¼ï¼Œä»å½¼æ­¤æ·±é‚ƒä¸”ç–²æƒ«çš„çœ¼çœ¸ä¸­ï¼Œçœ‹åˆ°äº†ç›¸åŒçš„å¯‚å¯ã€‚',
        npc: { name: 'é™Œç”Ÿé’“å‹', avatar: 'ğŸ£' },
        cond: (s) => s.catchWeight === 0 && s.stage > 2 && Math.random() < 0.5,
        choices: [
            { text: 'äº’è¯‰è¡·è‚ ', type: 'alliance_chat' },
            { text: 'æ¯”æ‹¼å®šåŠ› (æ¶ˆè€—20é¥µæ–™)', type: 'alliance_compete', cost: { type: 'bait', val: 20 } }
        ]
    },
    {
        id: 'wife_video_call',
        title: 'è€å©†çš„è§†é¢‘é€šè¯',
        atmosphere_intro: 'å¤©è‰²æ¸æš—ï¼Œå››å‘¨çš„è™«é¸£å£°å‚¬å¾—äººå¿ƒçƒ¦æ„ä¹±ã€‚çªç„¶ï¼Œè£¤å…œé‡Œä¸€é˜µæ€¥ä¿ƒçš„éœ‡åŠ¨è®©ä½ è™èº¯ä¸€éœ‡ï¼Œå±å¹•ä¸Šè·³åŠ¨çš„åå­—æ˜¯â€”â€”â€œè€å©†â€ã€‚',
        text: 'è€å©†æ‰“æ¥è§†é¢‘ï¼Œé•œå¤´é‡Œå…¨å®¶äººå›´åœ¨æ¡Œè¾¹ï¼Œéƒ½åœ¨ç­‰ç€ä½ çš„é±¼ä¸‹é”…ã€‚',
        npc: { name: 'è€å©†', avatar: 'ğŸ‘©' },
        cond: (s) => s.stage > 6 && s.stamina < 60 && Math.random() < 0.5,
        choices: [
            { text: 'å¼€å¯è™šå¹»æ‘„åƒå¤´ (éœ€å……ç”µå®)', type: 'wife_fake', req: 'powerbank' },
            { text: 'è¯šå®äº¤ä»£', type: 'wife_honest', cost: { type: 'sanity', val: 30 } },
            { text: 'å±•ç¤ºæ¸”è·', type: 'wife_show' }
        ]
    },
    {
        id: 'buy_fish',
        title: 'é‡æ€§æ¶ˆè´¹çš„è¯±æƒ‘',
        atmosphere_intro: 'éšç€ä¸€é˜µçªçªçªçš„å¼•æ“å£°ï¼Œå°˜åœŸé£æ‰¬ã€‚ä¸€è‚¡æµ“éƒçš„é±¼è…¥å‘³å…ˆäºå£°éŸ³é£˜è¿›äº†ä½ çš„é¼»è…”ï¼Œé‚£æ˜¯å¼ºè€…çš„æ°”æ¯ã€‚',
        text: 'ä¸€ä¸ªéª‘æ‘©æ‰˜çš„å½“åœ°è€ä¹¡è·¯è¿‡ï¼Œç­é‡Œæœ‰å‡ æ¡åˆšç½‘ä¸Šæ¥çš„æ´»é±¼ï¼Œçœ¼ç¥å……æ»¡æ·±æ„ã€‚',
        npc: { name: 'è€ä¹¡', avatar: 'ğŸ›µ' },
        cond: (s) => Math.random() < 0.4, // Remove money condition from spawn, check in choice
        choices: [
            { text: 'è´­ä¹°"å…¥åœºåˆ¸"', type: 'buy_fish', cost: { type: 'money', val: 200 } },
            { text: 'ä¸¥è¾æ‹’ç»', type: 'refuse_buy' }
        ]
    },
    // STANDARD EVENTS
    { id: 'fishing_spot', title: 'ç»ä½³é’“ç‚¹', text: 'æ°´è‰ä¸°èŒ‚ï¼Œå¿…å®šæœ‰è´§ã€‚ä½†æ˜¯æ—è¾¹æœ‰åªå‡¶çŒ›çš„å¤§é¹…ã€‚', icon: 'ğŸ¦¢', choices: [{ text: 'æˆ˜æ–—ï¼(ä½“åŠ›)', type: 'fight_goose', cost: { type: 'stamina', val: 20 } }, { text: 'ç»•è·¯ (å¿ƒæ€)', type: 'flee', cost: { type: 'sanity', val: 15 } }, { text: 'æŠ•å–‚ (éœ€é¥µæ–™)', type: 'feed', req: 'bait_any' }] },
    { id: 'storm', title: 'æš´é›¨å€¾ç›†', text: 'å¤©æ°”çªç„¶å˜è„¸ï¼Œç”µé—ªé›·é¸£ã€‚', icon: 'â›ˆï¸', choices: [{ text: 'ç¡¬æŠ— (å¿ƒæ€)', type: 'endure_storm', cost: { type: 'sanity', val: 25 } }, { text: 'èº²é¿ (æ¶ˆè€—å›åˆ)', type: 'skip_turn' }, { text: 'å¯Œè´µé™©ä¸­æ±‚ (é«˜é£é™©)', type: 'risk_fish', cost: { type: 'stamina', val: 30 } }] },
    { id: 'snag', title: 'æŒ‚åº•äº†', text: 'é±¼é’©æŒ‚åœ¨äº†åœ°ä¸Šï¼Œæ‹‰ä¸åŠ¨ã€‚', icon: 'ğŸª', choices: [{ text: 'å¤§åŠ›å‡ºå¥‡è¿¹ (ä½“åŠ›)', type: 'pull_hard', cost: { type: 'stamina', val: 15 } }, { text: 'åˆ‡çº¿ä¿æ† (å¿ƒæ€)', type: 'cut_line', cost: { type: 'sanity', val: 20 } }] },
    { id: 'normal_fish', title: 'å¹³é™çš„æ°´é¢', text: 'æµ®æ¼‚å¾®å¾®ç‚¹åŠ¨...', icon: 'ğŸŒŠ', choices: [{ text: 'æç«¿ï¼', type: 'fish_normal', cost: { type: 'stamina', val: 10 } }, { text: 'å†ç­‰ç­‰', type: 'wait_fish', cost: { type: 'sanity', val: 5 } }] },
    { id: 'security_check', title: 'ä¿å®‰æŸ¥è¯', text: 'â€œå–‚ï¼è¿™é‡Œä¸è®©é’“é±¼ï¼æœ‰è¯å—ï¼Ÿâ€', icon: 'ğŸ‘®', choices: [{ text: 'é€’ä¸Šä¸€æ ¹åå­', type: 'give_huazi', req: 'huazi' }, { text: 'æ®ç†åŠ›äº‰ (å¿ƒæ€)', type: 'argue', cost: { type: 'sanity', val: 15 } }, { text: 'ææ¡¶è·‘è·¯ (ä½“åŠ›)', type: 'run_away', cost: { type: 'stamina', val: 20 } }] },
    { id: 'mosquito_attack', title: 'èšŠè™«å¤§å†›', text: 'å—¡å—¡å—¡...å¤å¤œçš„èšŠå­åƒè½°ç‚¸æœºä¸€æ ·ã€‚', icon: 'ğŸ¦Ÿ', cond: (s) => s.stage > 5, choices: [{ text: 'å–·é©±èšŠæ°´', type: 'use_spray', req: 'spray' }, { text: 'å–‚èšŠå­ (å¿ƒæ€)', type: 'feed_mosquito', cost: { type: 'sanity', val: 20 } }, { text: 'ç‹‚æŠ½è‡ªå·± (ä½“åŠ›)', type: 'slap_mosquito', cost: { type: 'stamina', val: 10 } }] },
    { id: 'stray_cat', title: 'ä¸é€Ÿä¹‹å®¢', text: 'ä¸€åªæµæµªçŒ«ç›¯ç€ä½ çš„é±¼æŠ¤ã€‚', icon: 'ğŸ±', choices: [{ text: 'ç»™æ ¹ç«è…¿è‚ ', type: 'feed_sausage', req: 'sausage' }, { text: 'ç»™æ¡å°é±¼ (æ¸”è·-0.5kg)', type: 'give_fish', cond: (s) => s.catchWeight > 0.5 }, { text: 'èµ¶èµ°å®ƒ (å¿ƒæ€)', type: 'shoo_cat', cost: { type: 'sanity', val: 5 } }] },
    { id: 'grass_hole', title: 'å¤æ‚è‰æ´', text: 'å‰é¢æœ‰ä¸€ç‰‡å¯†é›†çš„æ°´è‰ï¼Œå¤§æ¿é²«æœ€çˆ±è—åœ¨è¿™é‡Œã€‚', icon: 'ğŸŒ¿', choices: [{ text: 'ç²¾å‡†ä¸‹é’© (éœ€é•¿ç«¿)', type: 'fish_hole', req: 'rod_giant_72' }, { text: 'å°è¯•ä½œé’“ (é«˜æŒ‚åº•ç‡)', type: 'fish_hole_risky', cost: { type: 'stamina', val: 15 } }, { text: 'æ”¾å¼ƒ', type: 'skip_turn' }] },
    { id: 'kfc', title: 'ç–¯ç‹‚æ˜ŸæœŸå››', text: 'æ­¤æ—¶æ­¤åˆ»ï¼Œä½ åªæƒ³åƒä¸€é¡¿å¥½çš„ã€‚', icon: 'ğŸ—', cond: (s) => s.stamina < 30, choices: [{ text: 'Væˆ‘50 (å›æ»¡)', type: 'eat_kfc' }, { text: 'å¿ä½ (å¿ƒæ€)', type: 'starve', cost: { type: 'sanity', val: 10 } }] },
    { id: 'eat_noodles', title: 'é¥¥è‚ è¾˜è¾˜', text: 'è‚šå­é¥¿å¾—å’•å’•å«ã€‚', icon: 'ğŸœ', cond: (s) => s.stamina < 50 && s.inventory.includes('noodles'), choices: [{ text: 'åƒæ³¡é¢ (å›30ä½“)', type: 'use_noodles' }, { text: 'æ¥ç€å¥ä¹æ¥ç€é’“', type: 'ignore_hunger' }] },
    { id: 'fellow_angler', title: 'è·¯é‡é’“å‹', text: 'â€œå…„å¼Ÿï¼Œæœ‰é¥µæ–™å—ï¼Ÿå€Ÿç‚¹æ€¥ç”¨ï¼Œä¸‹å›è¯·ä½ å–çº¢ç‰›ã€‚â€', icon: 'ğŸ¤·â€â™‚ï¸', cond: (s) => s.bait > 15, choices: [{ text: 'åˆ†ä»–ä¸€åŠ (é¥µæ–™å‡åŠ)', type: 'share_bait' }, { text: 'å‡è£…æ²¡å¬è§', type: 'ignore_angler' }] },
    { id: 'small_fish', title: 'å°é±¼é—¹çª', text: 'æµ®æ¼‚ä¸Šä¸‹ä¹±èˆï¼Œå…¨æ˜¯é¤æ¡åœ¨æ£ä¹±ã€‚', icon: 'ğŸŸ', choices: [{ text: 'åŠ å¤§æŠ•é¥µ (3å€æ¶ˆè€—)', type: 'heavy_feed_scare', cost: { type: 'bait', val: 3 } }, { text: 'å¬å¤©ç”±å‘½', type: 'wait_fish' }] }
];

createApp({
    setup() {
        const MAX_STAGES = 12;
        const state = reactive({
            phase: 'START',
            stamina: 100,
            sanity: 100,
            catchWeight: 0,
            money: 1000,
            inventory: [],
            discounts: [],
            stage: 1,
            logs: [],
            bait: 0,
            maxBait: 0,
            heavyChum: false,
            usingWorms: false,
            fishedCount: 0,
            initialBait: 0,
            flags: {
                firstCatch: false, stoleChicken: false, failedBigFish: 0, 
                drankWater: false, duckFlew: false, poisoned: false,
                huaziCount: 0, lightningStruck: false, pureFish: true, caughtAnything: false,
                sharedBait: false, boughtFish: false, grandpaBuff: false,
                marketSuccess: false, marketBusted: false,
                hasBigFish: false // Explicit flag for big fish
            },
            triggeredEvents: [], // FIX: Track triggered event IDs to prevent duplicates
            weather: 'CLEAR', // CLEAR, WINDY, STORM, NIGHT
            funnyLog: [],
            maxFishWeight: 0.0 // Track max weight for single fish
        });

        const activeTab = ref('ROD');
        const currentEvent = ref(null);
        const feedback = ref('');
        const newAchievements = ref([]);
        const logContainer = ref(null);
        const marketText = ref('');
        
        // Weight System
        const currentWeight = computed(() => {
            return state.inventory.reduce((sum, id) => {
                const item = ITEMS_DB.find(i => i.id === id);
                return sum + (item ? item.weight : 0);
            }, 0);
        });

        const currentStats = computed(() => {
            const rod = ITEMS_DB.find(i => state.inventory.includes(i.id) && i.category === 'ROD');
            const line = ITEMS_DB.find(i => state.inventory.includes(i.id) && i.category === 'LINE');
            const float = ITEMS_DB.find(i => state.inventory.includes(i.id) && i.category === 'FLOAT');

            const rodStrength = rod ? rod.strength : 0;
            const lineStrength = line ? line.maxLoad : 0;
            
            // If missing either, effective drag is 0 (or determined by the weak link if we assume hand-line)
            // But realistically, you need both.
            const maxDrag = (rod && line) ? Math.min(rodStrength, lineStrength) : 0;
            
            const sensitivity = (line ? (line.sensitivity || 0) : 0) + (float ? (float.sensitivity || 0) : 0);
            
            return { maxDrag, sensitivity };
        });

        const compatibilityWarning = computed(() => {
            const hasBigRod = state.inventory.includes('rod_giant_72');
            const hasThinLine = state.inventory.includes('line_08_thin');
            
            if (hasBigRod && hasThinLine) {
                return 'âš ï¸ è­¦å‘Šï¼šç”±äºçº¿ç»„è¿‡ç»†ï¼Œæ‚¨å¯èƒ½æ— æ³•å‘æŒ¥é±¼ç«¿çš„å…¨éƒ¨å¨åŠ›';
            }
            return '';
        });

        const canStart = computed(() => {
             // 1. Weight Check
             if (currentWeight.value > 10.0) return false;
             // 2. Essential Gear Check
             const hasLine = state.inventory.some(id => ITEMS_DB.find(i => i.id === id && i.category === 'LINE'));
             const hasFloat = state.inventory.some(id => ITEMS_DB.find(i => i.id === id && i.category === 'FLOAT'));
             return hasLine && hasFloat;
        });

        // Achievement System
        const unlockedAchievements = reactive(new Set());
        const activeToasts = ref([]);
        const showTrophyRoom = ref(false);
        const selectedAch = ref(null);

        onMounted(() => {
            const saved = localStorage.getItem('fishing_achievements');
            if(saved) {
                JSON.parse(saved).forEach(id => unlockedAchievements.add(id));
            }
        });

        const unlockAchievement = (id) => {
            if (unlockedAchievements.has(id)) return;
            const ach = ACHIEVEMENTS.find(a => a.id === id);
            if (!ach) return;

            unlockedAchievements.add(id);
            localStorage.setItem('fishing_achievements', JSON.stringify([...unlockedAchievements]));
            
            const toast = { id: Date.now(), name: ach.name, rarity: ach.rarity };
            activeToasts.value.push(toast);
            setTimeout(() => { activeToasts.value.shift(); }, 3000);

            if (!newAchievements.value.includes(ach.name)) {
                newAchievements.value.push(ach.name);
            }
        };

        const checkRealtimeAchievements = () => {
             if (state.flags.failedBigFish >= 5) unlockAchievement('line_breaker');
             if (state.flags.huaziCount >= 3) unlockAchievement('social_king');
             if (state.catchWeight > 10) unlockAchievement('super_catch');
             if (state.flags.lightningStruck) unlockAchievement('lightning_rod');
             if (state.flags.duckFlew) unlockAchievement('duck_flew');
        };

        const checkEndGameAchievements = () => {
            if (state.catchWeight === 0) unlockAchievement('air_force_commander');
            if (state.catchWeight > 0 && state.flags.pureFish && state.flags.caughtAnything && !state.flags.boughtFish && !state.flags.marketSuccess) unlockAchievement('pure_fish');
            if (state.catchWeight === 0 && (state.flags.stoleChicken || state.flags.drankWater)) unlockAchievement('never_empty');
            
            const baitCount = state.inventory.filter(id => {
                const item = ITEMS_DB.find(i => i.id === id);
                return item && item.category === 'BAIT';
            }).length;
            if (baitCount >= 4 && state.catchWeight < 1) unlockAchievement('bait_master');

            if (state.initialBait > 50 && state.fishedCount === 0) unlockAchievement('empty_promises');
            if (state.flags.boughtFish) unlockAchievement('cheater');
            
            // Market Achievements
            if (state.flags.marketBusted) unlockAchievement('bad_acting');
            if (state.flags.marketSuccess) unlockAchievement('movie_star');
        };

        // --- COMPUTED ---
        const filteredItems = computed(() => ITEMS_DB.filter(i => i.category === activeTab.value));
        const isDiscounted = (id) => state.discounts.includes(id);
        const unlockedCount = computed(() => unlockedAchievements.size);
        const hasAchievement = (id) => unlockedAchievements.has(id);
        const currentDate = computed(() => new Date().toLocaleDateString());
        
        const isLowBait = computed(() => state.maxBait > 0 && state.bait < state.maxBait * 0.1);
        const randomFunnyMoment = computed(() => {
            if (state.funnyLog.length === 0) return null;
            return state.funnyLog[Math.floor(Math.random() * state.funnyLog.length)];
        });

        const highestHonor = computed(() => {
            const unlocked = Array.from(unlockedAchievements).map(id => ACHIEVEMENTS.find(a => a.id === id));
            if(unlocked.length === 0) return 'åˆçº§é’“é±¼ä½¬';
            const legends = unlocked.filter(a => a.rarity === 'legend');
            if(legends.length > 0) return legends[legends.length - 1].name;
            const rares = unlocked.filter(a => a.rarity === 'rare');
            if(rares.length > 0) return rares[rares.length - 1].name;
            return unlocked[unlocked.length - 1].name;
        });

        const stampText = computed(() => {
            if (state.catchWeight === 0) return 'ç©ºå†›';
            if (state.catchWeight > 50) return 'çˆ†æŠ¤';
            return 'æ ¸å‡†';
        });

        const stampColor = computed(() => {
            if (state.catchWeight === 0) return '#555';
            if (state.catchWeight > 50) return '#d32f2f';
            return '#1976d2';
        });

        // --- ACTIONS ---
        const addLog = (msg) => {
            state.logs.push(msg);
            nextTick(() => { if(logContainer.value) logContainer.value.scrollTop = logContainer.value.scrollHeight; });
        };
        
        const recordFunny = (msg) => {
            state.funnyLog.push(msg);
        };

        const showAchDetail = (ach) => {
            if (hasAchievement(ach.id)) selectedAch.value = ach;
        };

        const startGame = () => {
            resetState();
            activeTab.value = 'ROD'; // FIX: Ensure Core Tackle is shown by default
            const allIds = ITEMS_DB.map(i => i.id);
            for(let i=0; i<3; i++) {
                const rand = allIds[Math.floor(Math.random() * allIds.length)];
                if(!state.discounts.includes(rand)) state.discounts.push(rand);
            }
            state.phase = 'PREPARE';
        };

        const resetState = () => {
            state.stamina = 100;
            state.sanity = 100;
            state.catchWeight = 0;
            state.money = 1000;
            state.inventory = [];
            state.discounts = [];
            state.stage = 1;
            state.logs = [];
            state.bait = 0;
            state.maxBait = 0;
            state.heavyChum = false;
            state.usingWorms = false;
            state.fishedCount = 0;
            state.initialBait = 0;
            state.triggeredEvents = []; // FIX: Reset triggered events
            state.flags = { 
                firstCatch: false, stoleChicken: false, failedBigFish: 0, 
                drankWater: false, duckFlew: false, poisoned: false,
                huaziCount: 0, lightningStruck: false, pureFish: true, caughtAnything: false,
                sharedBait: false, boughtFish: false, grandpaBuff: false,
                marketSuccess: false, marketBusted: false,
                hasBigFish: false
            };
            newAchievements.value = [];
            feedback.value = '';
            state.funnyLog = [];
            marketText.value = '';
        };

        const toggleItem = (item) => {
            const idx = state.inventory.indexOf(item.id);
            const price = isDiscounted(item.id) ? item.price / 2 : item.price;
            
            if (idx > -1) {
                state.inventory.splice(idx, 1);
                state.money += price;
            } else {
                if (state.inventory.length < 7 && state.money >= price) {
                    state.inventory.push(item.id);
                    state.money -= price;
                }
            }
        };

        const startJourney = () => {
            // Calculate Bait
            let totalBait = 0;
            state.inventory.forEach(id => {
                const item = ITEMS_DB.find(i => i.id === id);
                if (item && item.baitVal) totalBait += item.baitVal;
            });
            
            if (state.inventory.includes('aux_box')) {
                totalBait += 20;
            }

            if (totalBait === 0 && !state.inventory.includes('bait_grain') && !state.inventory.includes('bait_red_worms') && !state.inventory.includes('bait_potion')) {
                 addLog('æ²¡ä¹°é¥µæ–™ï¼Ÿåªå¥½æŒ–äº†ç‚¹èš¯èš“å‡‘åˆã€‚(é¥µæ–™+10)');
                 totalBait = 10;
            }

            state.bait = totalBait;
            state.maxBait = totalBait;
            state.initialBait = totalBait;
            
            state.phase = 'JOURNEY';
            nextStage();
        };

        const doHeavyChum = () => {
            if (state.bait >= 10) {
                state.bait -= 10;
                state.heavyChum = true;
                addLog('é‡çªå·²æ‰“ï¼åç­‰å·¨ç‰©ï¼');
            }
        };

        const doTasteBait = () => {
            if (state.bait <= 0) return;
            const outcome = Math.random();
            if (outcome > 0.5) {
                state.sanity += 5;
                state.bait -= 1;
                addLog('è¿™å‘³å„¿æ­£ï¼å¿ƒæ€+5');
                recordFunny('é¥¿æäº†èˆ”äº†ä¸€å£é±¼é¥µï¼Œç«Ÿç„¶è§‰å¾—å‘³é“ä¸é”™ã€‚');
            } else {
                state.stamina -= 15;
                state.bait -= 1;
                addLog('å‘¸ï¼è¿‡æœŸäº†ï¼è‚šå­å¥½ç—›... ä½“åŠ›-15');
                recordFunny('å·åƒé±¼é¥µå¯¼è‡´æ€¥æ€§è‚ èƒƒç‚ã€‚');
            }
        };

        const nextStage = () => {
            feedback.value = '';
            checkRealtimeAchievements();

            if (state.stamina <= 0 || state.sanity <= 0 || state.stage > MAX_STAGES) {
                triggerEndGame();
                return;
            }

            // Passive Effects
            if (state.inventory.includes('parallel_rod')) state.sanity += 2;
            if (state.inventory.includes('chemical') && state.stage > 5) {
                state.sanity -= 10;
                addLog('æ—è¾¹çš„é’“å‹å¯¹ä½ æŒ‡æŒ‡ç‚¹ç‚¹...');
            }

            // Check Bait
            if (state.bait <= 0 && !state.usingWorms) {
                const ev = EVENTS.find(e => e.id === 'no_bait');
                if(ev) { currentEvent.value = ev; return; }
            }

            // Random Events Logic
            let pool = EVENTS.filter(e => (!e.cond || e.cond(state)) && e.id !== 'no_bait');
            
            // Priority Events (Fix: Check priority events first and RETURN if triggered)
            if (state.stamina < 50 && state.inventory.includes('noodles') && Math.random() > 0.3) {
                const ev = EVENTS.find(e => e.id === 'eat_noodles');
                if(ev && !state.triggeredEvents.includes(ev.id)) { // FIX: Check duplication
                    currentEvent.value = ev; 
                    state.triggeredEvents.push(ev.id); // Mark triggered
                    return; 
                }
            }
            if (state.stage > 8 && !state.inventory.includes('spray') && Math.random() > 0.6) {
                 const ev = EVENTS.find(e => e.id === 'mosquito_attack');
                 if(ev && !state.triggeredEvents.includes(ev.id)) { // FIX: Check duplication
                     currentEvent.value = ev; 
                     state.triggeredEvents.push(ev.id); // Mark triggered
                     return; 
                 }
            }

            // High Priority NPC Events Check (Force check before standard pool)
            const npcEvents = EVENTS.filter(e => e.npc && e.cond && e.cond(state) && !state.triggeredEvents.includes(e.id)); // FIX: Filter out triggered
            if (npcEvents.length > 0) {
                 // 70% chance to pick an NPC event if available
                 if (Math.random() < 0.7) {
                     const ev = npcEvents[Math.floor(Math.random() * npcEvents.length)];
                     currentEvent.value = ev;
                     state.triggeredEvents.push(ev.id); // Mark triggered
                     return;
                 }
            }

            // Fallback to standard pool
            // Filter out NPC events if we decided not to show them (or if they failed condition)
            // But wait, 'pool' already contains valid events.
            // If pool is empty (rare), default to something safe
            if (pool.length === 0) {
                 const safeEv = EVENTS.find(e => e.id === 'normal_fish');
                 currentEvent.value = safeEv;
                 // Don't mark normal fish as triggered, as it can repeat
                 return;
            }

            // Filter pool for non-repeatable events (standard events can repeat, but maybe limit some unique ones?)
            // For now, let's assume only NPC/Story events are unique.
            // But user asked to fix duplication for "Story Content".
            // Let's make ALL events with an ID other than 'normal_fish', 'small_fish', 'snag', 'storm' unique per session?
            // Actually, let's just make the NPC/Special events unique.
            
            // Re-filter pool to exclude already triggered unique events
            // Let's define which ones are repeatable.
            // ONLY 'normal_fish' and 'small_fish' should be truly repeatable to fill gaps.
            // Everything else (snags, storms, random events) should ideally happen once or twice at most.
            // User requested: "try not to repeat event content".
            
            const repeatable = ['normal_fish', 'small_fish']; // Strictly limited repeatable events
            
            // Allow repeat if pool is too small, but prioritize unused
            let finalPool = pool.filter(e => !state.triggeredEvents.includes(e.id));
            
            if (finalPool.length === 0) {
                 // If run out of unique events, fallback to repeatable ones
                 finalPool = pool.filter(e => repeatable.includes(e.id));
            }
            
            if (finalPool.length === 0) {
                 // Absolute fallback
                 currentEvent.value = EVENTS.find(e => e.id === 'normal_fish');
                 return;
            }

            const ev = finalPool[Math.floor(Math.random() * finalPool.length)];
            currentEvent.value = ev;
            state.triggeredEvents.push(ev.id); // Mark ALL as triggered (even normal fish, but we handle logic above)
        };

        const canAfford = (choice) => {
            if (choice.req === 'bait_any') return state.bait > 5;
            if (choice.req && !state.inventory.includes(choice.req)) return false;
            
            if (choice.cost) {
                if (choice.cost.type === 'stamina' && state.stamina < choice.cost.val) return false;
                if (choice.cost.type === 'sanity' && state.sanity < choice.cost.val) return false;
                if (choice.cost.type === 'bait' && state.bait < choice.cost.val) return false;
                if (choice.cost.type === 'money' && state.money < choice.cost.val) return false;
            }
            return true;
        };

        const handleChoice = (choice) => {
            if (choice.cost) {
                let val = choice.cost.val;
                if (choice.cost.type === 'stamina') {
                    if (state.inventory.includes('lure_set')) val = Math.ceil(val * 1.1);
                    state.stamina -= val;
                }
                if (choice.cost.type === 'sanity') state.sanity -= val;
                if (choice.cost.type === 'bait') state.bait -= val;
                if (choice.cost.type === 'money') state.money -= val;
            }

            let msg = '';
            let success = Math.random() > 0.4;
            
            switch(choice.type) {
                // NPC EVENTS LOGIC
                case 'grandpa_ignore':
                    state.sanity -= 20;
                    msg = 'å¤§çˆ·åæ‰‹æ‹‰ä¸Šä¸€æ¡5kgè‰é±¼ã€‚ä½ å¿ƒæ€å´©äº†ã€‚';
                    recordFunny('è¢«æ‹¿æ ‘æé’“é±¼çš„å¤§çˆ·æ— æƒ…å˜²è®½ã€‚');
                    break;
                case 'grandpa_learn':
                    state.flags.grandpaBuff = true;
                    msg = 'å¤§çˆ·ä¼ æˆäº†â€œç¥çº§é’“ä½â€ã€‚æœ¬å±€å¤§é±¼æ¦‚ç‡+20%ï¼';
                    break;
                case 'grandpa_quit':
                    state.sanity = 0;
                    unlockAchievement('broken_heart');
                    msg = 'ä½ è¢«æ‰“å‡»å¾—ä½“æ— å®Œè‚¤ï¼ŒæŠ˜ç«¿å›å®¶ã€‚';
                    recordFunny('å› ä¸ºè¢«å¤§çˆ·å˜²è®½è€Œå½“åœºé€€å‘ã€‚');
                    break;
                case 'alliance_chat':
                    state.sanity += 20;
                    state.stamina += 10;
                    msg = 'ä½ ä»¬äº¤æµäº†å“ªå®¶å¤–å–æœ€å¥½åƒã€‚';
                    recordFunny('å’Œé™Œç”Ÿé’“å‹åœ¨æ²³è¾¹èŠäº†åŠå°æ—¶å¤–å–ã€‚');
                    break;
                case 'alliance_compete':
                    unlockAchievement('water_feeder');
                    msg = 'ä½ ä»¬ç–¯ç‹‚æ‰“çªï¼Œç»“æœä¾ç„¶ç©ºå†›ã€‚';
                    recordFunny('å’Œé’“å‹æ¯”æ‹¼æ‰“çªï¼ŒæŠŠé±¼éƒ½å–‚é¥±äº†ã€‚');
                    break;
                case 'wife_fake':
                    state.sanity += 5;
                    msg = 'å‡è£…ä¿¡å·ä¸å¥½ï¼Œè’™æ··è¿‡å…³ã€‚';
                    recordFunny('ç”¨å……ç”µå®åˆ¶é€ â€œä¿¡å·ä¸å¥½â€çš„å‡è±¡éª—è¿‡äº†è€å©†ã€‚');
                    break;
                case 'wife_honest':
                    msg = 'è€å©†è®©ä½ å»èœå¸‚åœºä¹°ä¸¤æ¡ã€‚';
                    recordFunny('è€å©†å»ºè®®å»èœå¸‚åœºè¿›è´§ã€‚');
                    break;
                case 'wife_show':
                    if (state.catchWeight > 0) {
                        state.sanity += 50;
                        msg = 'è€å©†å¤¸ä½ çœŸæ£’ï¼å®¶åº­åœ°ä½+1ã€‚';
                    } else {
                        state.stamina -= 10;
                        msg = 'ç©ºæ°”çªç„¶å®‰é™... å°´å°¬å¾—è„šè¶¾æ‰£åœ°ã€‚';
                        recordFunny('è§†é¢‘é€šè¯å±•ç¤ºç©ºæ¡¶ï¼Œå…¨å®¶æ²‰é»˜ã€‚');
                    }
                    break;
                case 'monster_brag':
                    state.sanity = 100;
                    unlockAchievement('local_king');
                    msg = 'å…¨åœºæœ€ä½³ï¼ä½ å°±æ˜¯è¿™æ¡æ²³çš„ç‹ï¼';
                    recordFunny('ç»™å…¨æ‘äººå‘çƒŸå¹å˜˜è‡ªå·±é’“çš„å¤§é±¼ã€‚');
                    break;
                case 'monster_humble':
                    state.sanity += 20;
                    unlockAchievement('versailles');
                    msg = 'â€œè¿™ç§é±¼æˆ‘å¹³æ—¶éƒ½æ”¾ç”Ÿçš„ã€‚â€';
                    recordFunny('é’“åˆ°å·¨ç‰©åå‡¡å°”èµ›å‘è¨€ã€‚');
                    break;
                case 'monster_market':
                    state.sanity += 30;
                    state.stamina -= 20;
                    state.flags.marketParade = true; // No scam check
                    msg = 'é±¼è´©å­çœ‹å‚»äº†çœ¼ã€‚';
                    recordFunny('æŠŠå·¨ç‰©ç»‘åœ¨è½¦ååº§å»èœå¸‚åœºæ¸¸è¡—ã€‚');
                    break;
                case 'monster_home':
                    unlockAchievement('family_status_up');
                    msg = 'å›å®¶ï¼ä»Šå¤©å¿…é¡»åŠ é¤ï¼';
                    triggerEndGame();
                    return;
                case 'buy_fish':
                    state.flags.boughtFish = true;
                    state.catchWeight += 5.0; // FIX: Actually add weight
                    msg = 'å«æ³ªä¹°ä¸‹è€ä¹¡çš„é±¼ã€‚è·å¾—æ¸”è· 5.0kg';
                    recordFunny('èŠ±é’±ä¹°è€ä¹¡çš„é±¼å†’å……æˆ˜ç»©ã€‚');
                    break;
                case 'refuse_buy':
                    state.sanity += 10;
                    msg = 'æˆ‘é’“çš„æ˜¯å¯‚å¯ï¼Œä¸æ˜¯é±¼ã€‚';
                    break;

                // STANDARD EVENTS LOGIC
                case 'find_worms':
                    if (Math.random() > 0.5) {
                        state.bait += 5; // FIX: Add real bait to unlock UI
                        state.maxBait = Math.max(state.maxBait, state.bait);
                        state.usingWorms = true; // Mark as using worms for achievement
                        msg = 'æŒ–åˆ°äº†å‡ æ¡çº¢èš¯èš“ï¼(é¥µæ–™+5)';
                        // fishing(false); // Removed to allow normal event flow
                    } else {
                        msg = 'é™¤äº†æ³¥å·´ä»€ä¹ˆä¹Ÿæ²¡æœ‰...';
                        state.sanity -= 10;
                        recordFunny('åœ¨æ²³è¾¹æŒ–æ³¥å·´æŒ–äº†åŠå¤©ã€‚');
                    }
                    break;
                case 'give_up':
                    triggerEndGame();
                    return;
                case 'share_bait':
                    state.bait = Math.floor(state.bait / 2);
                    state.flags.sharedBait = true;
                    msg = 'èµ äººç«ç‘°ï¼Œæ‰‹æœ‰ä½™é¦™ã€‚';
                    state.sanity += 10;
                    break;
                case 'ignore_angler':
                    msg = 'ä½ å‡è£…åœ¨çœ‹é£æ™¯ã€‚';
                    break;
                case 'heavy_feed_scare':
                    msg = 'ä¸€é¡¿ç‹‚è½°æ»¥ç‚¸ï¼Œå°é±¼æ•£äº†ã€‚';
                    state.heavyChum = true;
                    break;
                case 'fight_goose':
                    if (success) { msg = 'æˆ˜èƒœäº†å¤§é¹…ï¼'; fishing(true); } 
                    else { msg = 'è¢«å¤§é¹…å•„ä¼¤...'; state.sanity -= 20; recordFunny('è¢«ä¸€åªå¤§é¹…è¿½ç€å’¬ã€‚'); }
                    break;
                case 'feed':
                    state.bait -= 5;
                    msg = 'å¤§é¹…åƒé¥±äº†ã€‚'; fishing(false);
                    break;
                case 'endure_storm':
                    if (state.inventory.includes('big_umbrella')) msg = 'æœ‰å¤§ä¼ï¼Œç¨³å¦‚æ³°å±±ã€‚';
                    else { msg = 'æ·‹æˆè½æ±¤é¸¡ã€‚'; state.sanity -= 10; recordFunny('åœ¨æš´é›¨ä¸­æ€è€ƒäººç”Ÿã€‚'); }
                    break;
                case 'risk_fish':
                     if (state.inventory.includes('big_umbrella')) {
                         msg = 'é›·é›¨å¤©ä½œé’“ï¼Œç‹‚æ‹‰ï¼'; fishing(true);
                     } else {
                        if (Math.random() > 0.7) { msg = 'å¯Œè´µé™©ä¸­æ±‚ï¼'; fishing(true); }
                        else { msg = 'è¢«é›·åŠˆäº†ï¼'; state.sanity -= 50; state.stamina -= 50; state.flags.lightningStruck = true; recordFunny('è¢«é›·åŠˆäº†è¿˜åœ¨åšæŒä½œé’“ã€‚'); }
                     }
                     break;
                case 'give_huazi':
                    msg = 'ä¿å®‰å¤§å“¥æŠ½äº†åå­ï¼Œç¥ä½ çˆ†æŠ¤ã€‚';
                    state.sanity += 10;
                    state.flags.huaziCount++;
                    break;
                case 'argue':
                    msg = 'ä¿å®‰æŠŠä½ èµ¶èµ°äº†ã€‚'; state.sanity -= 15;
                    recordFunny('å’Œä¿å®‰åµæ¶è¢«èµ¶å‡ºé’“ç‚¹ã€‚');
                    break;
                case 'use_spray':
                    msg = 'èšŠå­éƒ½ä¸æ•¢è¿‘èº«ã€‚';
                    break;
                case 'feed_mosquito':
                    msg = 'èˆèº«å–‚èšŠ...';
                    break;
                case 'feed_sausage':
                    if (Math.random() > 0.3) { msg = 'çŒ«å’ªåƒå¾—å¾ˆå¼€å¿ƒï¼Œå‘¼å™œå‘¼å™œå¯åŠ¨äº†å¸ç‹å¼•æ“ã€‚'; } else { msg = 'çŒ«å’ªåƒå®Œå«Œå¼ƒåœ°èµ°äº†ã€‚'; }
                    if (currentEvent.value.id === 'stray_cat' && Math.random() > 0.8) { state.flags.poisoned = true; msg += ' ä½†ä½ é—»åˆ°ç«è…¿è‚ å¥½åƒé¦Šäº†...'; }
                    break;
                case 'give_fish':
                    state.catchWeight = Math.max(0, state.catchWeight - 0.5);
                    msg = 'ä½ æŒ‘äº†ä¸€æ¡æœ€å°çš„é±¼å–‚ç»™çŒ«å’ªã€‚çŒ«å’ªå¾ˆæ»¡æ„ã€‚';
                    state.sanity += 10;
                    break;
                case 'shoo_cat':
                    msg = 'ä½ èµ¶èµ°äº†çŒ«ã€‚è‰¯å¿ƒæœ‰ç‚¹ç—›ã€‚';
                    state.sanity -= 5;
                    break;
                case 'fish_hole':
                    msg = 'ä¸ƒæ˜Ÿæ¼‚å°±æ˜¯å¥½ç”¨ï¼'; fishing(true);
                    break;
                case 'fish_hole_risky':
                    if(Math.random() > 0.8) { msg = 'è¿æ°”å¥½ï¼Œæ‹‰å‡ºæ¥äº†ï¼'; fishing(true); } else { msg = 'æŒ‚è‰äº†ï¼Œæ— å¥ˆæ–­çº¿ã€‚'; state.sanity -= 10; }
                    break;
                case 'use_noodles':
                    state.stamina += 30;
                    msg = 'ä¸€ç¢—æ³¡é¢ä¸‹è‚šï¼Œçµé­‚å¤è‹ã€‚';
                    break;
                case 'fish_normal':
                    fishing(false);
                    break;
                case 'pull_hard':
                    if (state.stamina <= 5 || state.sanity <= 5) unlockAchievement('ultimate_regret');
                    
                    // Extreme Fishing Logic: Allow over-exertion for big fish chance
                    if (state.stamina < 15 && state.inventory.includes('pe_line')) {
                         state.sanity -= 20; // Mental breakdown instead of stamina
                         msg = 'ã€æé™æ‹‰ç«¿ã€‘é€æ”¯å¿ƒæ€å¼ºè¡Œèµ·é±¼ï¼';
                         fishing(false);
                    } else if (state.stamina < 15) {
                         msg = 'ä½“åŠ›ä¸æ”¯ï¼Œæ‹‰ä¸åŠ¨äº†...';
                    } else if (state.inventory.includes('pe_line')) { 
                        msg = 'å¤§åŠ›é©¬çº¿å°±æ˜¯å¼ºï¼ç¡¬æ‹‰å›æ¥äº†ï¼'; fishing(false); 
                    } else { 
                        if (Math.random() > 0.5) { msg = 'æ‹‰å›æ¥äº†ï¼'; fishing(false); } 
                        else { msg = 'åˆ‡çº¿äº†...'; state.sanity -= 30; state.flags.failedBigFish++; recordFunny('å› ä¸ºä¸æƒ³åˆ‡çº¿è€Œå¿ƒæ€çˆ†ç‚¸ã€‚'); } 
                    }
                    break;
                case 'cut_line':
                    msg = 'åŠæ—¶æ­¢æŸã€‚';
                    break;
                case 'steal_chicken':
                    state.flags.stoleChicken = true;
                    msg = 'é¡ºèµ°äº†ä¸€åªé¸¡...';
                    recordFunny('å› ä¸ºæ²¡é’“åˆ°é±¼é¡ºèµ°äº†æ‘æ°‘ä¸€åªé¸¡ã€‚');
                    break;
                case 'drink_water':
                    state.flags.drankWater = true;
                    state.stamina += 20;
                    msg = 'å–äº†å£äº•æ°´ã€‚';
                    break;
                default:
                    msg = 'æ— äº‹å‘ç”Ÿã€‚';
            }

            addLog(msg);
            feedback.value = msg;
            setTimeout(() => { state.stage++; nextStage(); }, 1500);
        };

        const fishing = (isBonus) => {
            // Check Bait Consumption
            let baitCost = 2;
            if (state.usingWorms) baitCost = 0; 
            
            // Rod Stamina Cost Modifiers
            let staminaCost = 10; 
            if (state.inventory.includes('rod_carbon_light')) staminaCost = 7; 
            if (state.inventory.includes('rod_giant_72')) staminaCost = 20; 

            // Line & Float Logic
            const line = ITEMS_DB.find(i => state.inventory.includes(i.id) && i.category === 'LINE');
            const float = ITEMS_DB.find(i => state.inventory.includes(i.id) && i.category === 'FLOAT');
            const rod = ITEMS_DB.find(i => state.inventory.includes(i.id) && i.category === 'ROD');

            if (line && line.id === 'line_80_pe') staminaCost += 5; // Heavy line penalty
            
            // Heavy Load Penalty Logic (Dynamic)
            if (currentWeight.value >= 8.0) {
                 staminaCost = Math.ceil(staminaCost * 1.2);
            }

            if (!state.usingWorms && state.bait < baitCost) {
                addLog('é¥µæ–™ä¸è¶³ï¼Œæ— æ³•ä½œé’“ï¼');
                return;
            }
            if (state.stamina < staminaCost) {
                addLog('ä½“åŠ›é€æ”¯ï¼Œæ— æ³•æŠ›ç«¿ï¼');
                return;
            }

            if (!state.usingWorms) state.bait -= baitCost;
            state.stamina -= staminaCost;

            state.fishedCount++;

            // Weather & Float Miss Logic
            if ((state.weather === 'WINDY' || state.weather === 'STORM') && float?.id === 'float_reed') {
                if (Math.random() < 0.5) {
                    addLog('ã€ç©ºç«¿ã€‘é£å¤ªå¤§ï¼ŒèŠ¦è‹‡æ¼‚ä¹±èˆï¼Œæäº†ä¸ªå¯‚å¯ã€‚');
                    state.sanity -= 5;
                    return; 
                }
            }

            // Night Penalty Check
            if (state.weather === 'NIGHT' && float?.id !== 'float_electric') {
                 if (Math.random() < 0.6) {
                     addLog('ã€çœ‹ä¸æ¸…ã€‘å¤ªé»‘äº†ï¼Œå®Œå…¨çœ‹ä¸æ¸…æ¼‚ç›¸ï¼');
                     return;
                 }
            }

            let loops = 1;
            if (state.inventory.includes('gold_disgorger')) loops = 2;
            if (state.inventory.includes('bait_potion')) loops = 2; 

            let totalWeight = 0;

            for(let i=0; i<loops; i++) {
                // Potion Risk
                if (state.inventory.includes('bait_potion') && Math.random() < 0.2) {
                    addLog('å°è¯çƒ§æ‰‹ï¼ä½“åŠ›-10ï¼Œé±¼ç¾¤æƒŠæ•£ï¼');
                    state.stamina -= 10;
                    continue;
                }

                // Grain Logic: Slow start
                if (state.inventory.includes('bait_grain') && state.stage <= 3) {
                    addLog('çªæ–™è¿˜æ²¡å‘çª...');
                    continue;
                }

                let isSmall = Math.random() > 0.5;
                
                // Heavy Chum Effect
                if (state.heavyChum) {
                    if (Math.random() < 0.3) isSmall = false; 
                }
                
                // Grandpa Buff
                if (state.flags.grandpaBuff) {
                    if (Math.random() < 0.2) isSmall = false; 
                }

                // Line Modifiers (Small Fish Rate)
                if (line?.id === 'line_08_thin') {
                    if (Math.random() < 0.75) isSmall = true; // +40% approx
                }
                if (line?.id === 'line_80_pe') {
                    isSmall = false; // No small fish
                    if (Math.random() < 0.3) { 
                        addLog('çº¿ç»„å¤ªç²—ï¼Œé±¼ä¸æ•¢åƒé’©...');
                        continue; 
                    }
                }
                // Float Modifiers (Scare)
                if (float?.id === 'float_electric') {
                    if (Math.random() < 0.2) {
                         addLog('ç”µå­æ¼‚å¤ªäº®ï¼Œå¤§é±¼è¢«å“è·‘äº†ã€‚');
                         continue;
                    }
                }

                if (state.stage === 1 && !state.flags.firstCatch) {
                    isBonus = true; state.flags.firstCatch = true; addLog('æ–°æ‰‹ä¿æŠ¤æœŸç”Ÿæ•ˆï¼');
                }

                let weight = 0;
                if (state.inventory.includes('broken_net') && (isBonus || !isSmall) && Math.random() < 0.3) {
                    state.flags.duckFlew = true; addLog('å“å‘€ï¼ç½‘ç ´äº†ï¼å¤§é±¼è·‘äº†ï¼'); recordFunny('å¤§é±¼åˆ°ç½‘å£å› ä¸ºç½‘ç ´äº†è·‘äº†ã€‚'); continue;
                }

                if (isBonus || !isSmall) {
                    // Big Fish
                    // Reduced base weight for scarcity
                    weight = 0.5 + Math.random() * 2; // Normal big: 0.5-2.5kg
                    
                    // Monster Chance (Low but impactful)
                    // Base chance 2%, +1% if lucky items
                    let monsterChance = 0.02; 
                    if (state.inventory.includes('gold_disgorger')) monsterChance += 0.01;
                    
                    if (Math.random() < monsterChance) {
                        weight = 5.1 + Math.random() * 10; // Monster: 5.1-15kg
                    } else if (state.inventory.includes('gold_disgorger') && Math.random() < 0.05) {
                        // Rusty Anchor Curse
                        addLog('é’“åˆ°äº†...ä¸€ä¸ªç”Ÿé”ˆçš„é“é”šï¼Ÿ(é‡‘è‰²æŒ¡é’ˆçš„å‰¯ä½œç”¨)');
                        weight = 0;
                        state.sanity -= 10;
                    }

                    if (state.inventory.includes('bait_grain') && state.stage > 8) weight += 1; // Grain bonus reduced
                    
                    // 1. Rod Break Check
                    if (rod && weight > rod.strength && Math.random() < 0.4) {
                        addLog(`ã€çˆ†ç«¿ã€‘${weight.toFixed(1)}kgå¤§é±¼æ‹‰æ–­äº†${rod.name}ï¼`);
                        state.sanity -= 30;
                        weight = 0;
                        // Ideally remove rod, but let's keep it simple for now or implement lose logic
                    }

                    // 2. Line Snap Check
                    if (line && weight > line.maxLoad) {
                        addLog(`ã€åˆ‡çº¿ã€‘${weight.toFixed(1)}kgå¤§é±¼ç§’åˆ‡${line.name}ï¼`);
                        weight = 0;
                        state.sanity -= 20;
                        unlockAchievement('line_breaker');
                    }

                    // Monster Trigger
                if (weight > 5.0) {
                    state.flags.hasBigFish = true; // Mark as big fish
                    triggerMonsterMinigame(weight);
                    // Skip adding weight now, wait for minigame result
                    weight = 0; 
                } else if (weight > state.maxFishWeight) {
                    state.maxFishWeight = weight; // Update max record for normal fish
                }

                } else {
                    // Small Fish (Scarcity: 0.2 - 0.8kg)
                    weight = 0.2 + Math.random() * 0.6;
                    if (state.inventory.includes('bait_red_worms') && Math.random() < 0.3) {
                        addLog('é’“ä¸Šæ¥ä¸€åªç ´é‹...');
                        weight = 0;
                        state.flags.pureFish = false;
                        recordFunny('é’“ä¸Šæ¥ä¸€åªè‡­æ°´é‹ã€‚');
                    }
                }

                if (weight > 0) state.flags.caughtAnything = true;
                totalWeight += weight;
            }
            
            // Survivalist Check
            if (state.usingWorms && totalWeight > 0) {
                unlockAchievement('survivalist');
            }
            // Reset temp flags
            state.heavyChum = false;
            state.usingWorms = false;

            if(totalWeight > 0) {
                 state.catchWeight += totalWeight;
                 feedback.value = `è·å¾—æ¸”è· ${totalWeight.toFixed(1)}kg`;
            } else if (!monsterMinigame.active) {
                 // Only show empty if no minigame triggered
            }
        };

        const triggerMonsterMinigame = (weight) => {
            monsterMinigame.active = true;
            monsterMinigame.cursor = 50;
            monsterMinigame.velocity = 0;
            monsterMinigame.timeLeft = 5;
            monsterMinigame.targetWeight = weight;
            
            // Start Loop
            monsterMinigame.interval = setInterval(() => {
                // Physics
                monsterMinigame.velocity += (Math.random() - 0.5) * 4; // Random turbulence
                monsterMinigame.cursor += monsterMinigame.velocity;
                
                // Bounds bounce
                if (monsterMinigame.cursor < 0 || monsterMinigame.cursor > 100) {
                    monsterMinigame.velocity *= -0.8;
                    monsterMinigame.cursor = Math.max(0, Math.min(100, monsterMinigame.cursor));
                }

                monsterMinigame.timeLeft -= 0.1;

                if (monsterMinigame.timeLeft <= 0) {
                    endMonsterMinigame(true);
                }
            }, 100);
        };

        const monsterAction = (dir) => {
            if (dir === 'left') monsterMinigame.velocity -= 5;
            if (dir === 'right') monsterMinigame.velocity += 5;
        };

        const endMonsterMinigame = (success) => {
            clearInterval(monsterMinigame.interval);
            monsterMinigame.active = false;
            
            // Check final position
            if (success) {
                // Check if cursor is in safe zone (35-65)
                if (monsterMinigame.cursor >= 35 && monsterMinigame.cursor <= 65) {
                    // Success!
                    triggerMonsterEvent(monsterMinigame.targetWeight);
                } else {
                    // Fail
                    addLog('ã€è·‘é±¼ã€‘å¤§é±¼å‘åŠ›ï¼Œè„±é’©è€Œå»ï¼');
                    state.sanity -= 30;
                }
            }
        };

        const triggerMonsterEvent = (weight) => {
            // Update max weight record
            if (weight > state.maxFishWeight) state.maxFishWeight = weight;
            state.flags.hasBigFish = true;

            // Visuals
            triggerPhoto(weight);
            state.catchWeight += weight;
            
            // Trigger Event
            setTimeout(() => {
                const eventType = Math.random() > 0.5 ? 'village_watch' : 'victory_parade';
                currentEvent.value = {
                    id: eventType,
                    title: eventType === 'village_watch' ? 'å…¨æ‘å›´è§‚' : 'å‡¯æ—‹æ¸¸è¡—',
                    text: eventType === 'village_watch' 
                        ? `ä½ åˆšæŠŠ${weight.toFixed(1)}kgå·¨ç‰©æ‹–ä¸Šå²¸ï¼Œæ–¹åœ†ä¸¤å…¬é‡Œçš„é’“å‹ã€å¤–å–å°å“¥ã€æ”¾ç¾Šå¤§çˆ·éƒ½å›´äº†è¿‡æ¥ã€‚`
                        : `ç”±äº${weight.toFixed(1)}kgé±¼å¤ªå¤§ï¼Œé±¼æŠ¤å¡ä¸ä¸‹ã€‚ä½ å†³å®šæŠŠå®ƒç»‘åœ¨è½¦ååº§ã€‚`,
                    choices: eventType === 'village_watch' 
                        ? [
                            { text: 'é€’çƒŸå¹å˜˜ (éœ€åå­)', type: 'monster_brag', req: 'huazi' },
                            { text: 'äº‘æ·¡é£è½»', type: 'monster_humble' }
                          ]
                        : [
                            { text: 'ç»•è·¯å»èœå¸‚åœº', type: 'monster_market', cost: { type: 'stamina', val: 20 } },
                            { text: 'ä½è°ƒå›å®¶', type: 'monster_home' }
                          ]
                };
            }, 3000); // Wait for photo
        };

        const triggerPhoto = (weight) => {
            monsterPhoto.active = true;
            monsterPhoto.weight = weight.toFixed(1);
            monsterPhoto.fishName = 'ä¼ è¯´å·¨ç‰©';
            monsterPhoto.danmaku = ['å§æ§½ï¼', '666', 'è¿™æ˜¯äººå¹²çš„äº‹ï¼Ÿ', 'å¤§å¸ˆæ±‚å¸¦', 'è¿™ä¹Ÿå¤ªå¤§äº†å§'];
        };

        const closePhoto = () => {
            monsterPhoto.active = false;
        };

        const triggerEndGame = () => {
            // FIX: Market condition: Only if catchWeight is 0 (Air Force) AND has money
            if (state.catchWeight === 0 && state.money >= 100 && !state.flags.marketParade) { 
                state.phase = 'MARKET_INTRO'; // New Intro Phase
                // No need to set marketText here, UI will handle intro
            } else {
                endGame();
            }
        };

        const enterMarket = () => {
            state.phase = 'MARKET';
        };

        const getRealProb = (item) => {
            let p = item.prob;
            if (state.inventory.includes('huazi')) {
                p -= 0.2;
            }
            if (state.inventory.includes('aux_ice_bucket')) {
                p -= 0.15;
            }
            return Math.max(0, p);
        };

        const buyFish = (item) => {
            if (state.money < item.price) return;
            state.money -= item.price;
            
            // Check Scam
            const bustProb = getRealProb(item);
            
            if (Math.random() < bustProb) {
                // Busted
                state.flags.marketBusted = true;
                state.catchWeight = 0;
                
                const reasons = [
                    "è€å©†çœ‹ç€é±¼å˜´é‡Œçš„é±¼é’©ç—•è¿¹ï¼Œé™·å…¥äº†æ²‰æ€ï¼šâ€˜ç°åœ¨çš„é±¼ï¼Œä¸Šé’©å‰è¿˜è‡ªå¸¦è¶…å¸‚çš„æ ‡ç­¾ç­¾å—ï¼Ÿâ€™",
                    "ä½ å¦ˆæ¥è¿‡é±¼ï¼šâ€˜å„¿å•Šï¼Œè¿™é±¼è‚šå­é‡Œæ€ä¹ˆè¿˜æœ‰ä¸€è‚¡å†·åº“çš„å†°æ¸£å‘³ï¼Ÿâ€™",
                    "é‚»å±…è€ç‹è·¯è¿‡ï¼šâ€˜å“Ÿï¼Œè¿™å“ç§å’±è¿™æ°´åº“å¯æ²¡è§è¿‡ï¼Œæ˜¯ä»å¤ªå¹³æ´‹æ¸¸è¿‡æ¥çš„å§ï¼Ÿâ€™"
                ];
                marketText.value = reasons[Math.floor(Math.random() * reasons.length)];
                recordFunny('è¯•å›¾åœ¨èœå¸‚åœºä¹°é±¼å†’å……æˆ˜ç»©ï¼Œè¢«å®¶äººå½“åœºè¯†ç ´ã€‚');
            } else {
                // Success
                state.flags.marketSuccess = true;
                state.catchWeight += item.weight;
            }
            
            endGame();
        };

        const leaveMarket = () => {
            endGame();
        };

        const endGame = () => {
            state.phase = 'ENDED';
            checkEndGameAchievements();
        };

        const endingTitle = computed(() => {
            if (state.flags.hasBigFish || state.flags.marketSuccess || state.flags.marketParade) return 'è£è€€æ—¶åˆ»';
            if (state.flags.marketBusted) return 'å®¶åº­å¼Ÿä½';
            if (state.stamina > 0 && state.sanity > 0) return 'é—æ†¾æ”¶ç«¿';
            return 'é“å¿ƒç ´ç¢';
        });

        const endingIcon = computed(() => {
            if (state.flags.marketBusted) return 'ğŸ™‡';
            
            const hasBigFish = state.catchWeight >= 5.0 || state.flags.boughtFish || state.flags.marketSuccess;
            if (state.stamina <= 0) {
                 return hasBigFish ? 'ğŸ†' : 'ğŸš‘';
            }

            if (state.sanity <= 0) return 'ğŸ’”';
            if (hasBigFish) return 'ğŸ†';
            if (state.catchWeight > 0) return 'ğŸŸ';
            return 'ğŸª£';
        });

        const shareText = computed(() => {
            if (!state.inventory.includes('powerbank') && Math.random() > 0.5) return "æ‰‹æœºæ²¡ç”µäº†ï¼Œæ— æ³•åˆ†äº«æˆ˜ç»©...";
            const place = 'ç¥ç§˜æ°´åº“';
            let result = '';
            
            const hasBigFish = state.catchWeight >= 5.0 || state.flags.boughtFish || state.flags.marketSuccess;

            // Monster Override
            if (state.flags.marketParade) {
                 return `æˆ‘ä»Šå¤©åœ¨${place}æ–©è·ä¼ è¯´å·¨ç‰©ä¸€æ¡ï¼ç»‘åœ¨è½¦ååº§è·¯è¿‡èœå¸‚åœºæ—¶ï¼Œé‚£é‡Œçš„é±¼è´©å­éƒ½çœ‹å‚»äº†...`;
            }
            if (hasAchievement('local_king')) {
                 return `æˆ‘ä»Šå¤©åœ¨${place}é’“åˆ°å·¨ç‰©ï¼Œå…¨æ‘äººéƒ½æ¥å›´è§‚äº†ï¼Œä¸å¾—ä¸ç»™æ¯äººå‘äº†ä¸€æ ¹åå­ã€‚`;
            }

            if (state.flags.marketBusted) { 
                result = 'ä»Šå¤©å»èœå¸‚åœºè¿›è´§è¢«æŠ“äº†ä¸ªç°è¡Œ...'; 
            } else if (state.stamina <= 0 && hasBigFish) {
                result = 'ä½ ç”±äºè„±åŠ›æ™•å€’åœ¨æ°´åº“è¾¹ï¼Œä½†åŒæ‰‹ä¾ç„¶æ­»æ­»æŠ±ç€é‚£æ¡ 10 æ–¤çš„å¤§è‰é±¼ã€‚è·¯è¿‡çš„é’“å‹çº·çº·æŠ•æ¥æ•¬ä½©çš„ç›®å…‰ã€‚';
                return `æˆ‘æ˜¯é’“é±¼ä½¬ï¼Œä»Šå¤©æˆ‘åœ¨${place}ï¼Œ${result}`;
            } else if (state.stamina <= 0 && !hasBigFish) {
                result = 'é±¼æ²¡ä¸Šæ¥ï¼Œäººä¸Šå»äº†ã€‚';
            } else if (hasBigFish) {
                result = 'è¿™ä¸€æ†ï¼Œæˆ‘å¹ä¸€è¾ˆå­ï¼';
            } else if (state.catchWeight > 0) {
                 result = `è™½æ— å·¨ç‰©ï¼Œä½†ä¹Ÿæ–©è· ${state.catchWeight.toFixed(1)}kg é±¼ï¼`; 
            } else {
                 result = 'é±¼æ²¡é’“åˆ°ï¼Œå€’æ˜¯æŠŠèº«ä½“é”»ç‚¼å¥½äº†ã€‚';
            }

            return `æˆ‘æ˜¯é’“é±¼ä½¬ï¼Œä»Šå¤©æˆ‘åœ¨${place}ï¼Œ${result}`;
        });

        const generatePoster = () => {
            const el = document.getElementById('license-node');
            if(!el) return;
            html2canvas(el, { backgroundColor: null }).then(canvas => {
                const link = document.createElement('a');
                link.download = `fishing-license-${Date.now()}.png`;
                link.href = canvas.toDataURL();
                link.click();
            });
        };

        const resetGame = () => {
            state.phase = 'START';
        };

        return {
            state, CATEGORIES, ACHIEVEMENTS, activeTab, filteredItems, currentEvent, MAX_STAGES, MARKET_ITEMS,
            startGame, startJourney, toggleItem, handleChoice, feedback, logContainer, canAfford,
            endingTitle, endingIcon, newAchievements, shareText, resetGame, isDiscounted,
            activeToasts, showTrophyRoom, unlockedCount, hasAchievement, showAchDetail, selectedAch,
            currentDate, highestHonor, stampText, stampColor, generatePoster,
            doHeavyChum, doTasteBait, isLowBait, randomFunnyMoment, marketText,
            triggerEndGame, buyFish, leaveMarket, getRealProb,
            currentWeight, currentStats, compatibilityWarning, canStart, enterMarket
        };
    }
}).mount('#app');
</script>
</body>
</html>
